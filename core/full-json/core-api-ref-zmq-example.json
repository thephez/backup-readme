{
 "metadata": {
  "image": [],
  "title": "",
  "description": "",
  "keywords": "",
  "robots": "index"
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 200
    },
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 400
    }
   ]
  },
  "params": []
 },
 "next": {
  "description": "",
  "pages": []
 },
 "algolia": {
  "recordCount": 1,
  "publishPending": false,
  "translationFailure": false,
  "updatedAt": "2023-02-21T19:16:07.883Z"
 },
 "title": "ZMQ Example",
 "icon": "",
 "updates": [],
 "type": "basic",
 "slug": "core-api-ref-zmq-example",
 "excerpt": "",
 "body": "> \ud83d\udea7 New site!\n>\n> All content has been migrated to docs.dash.org. You will be automatically redirected momentarily.\n[block:html]\n{\n  \"html\": \"<div></div>\\n<meta http-equiv=\\\"refresh\\\" content=\\\"2; url='https://dash-user-docs.readthedocs.io/projects/core/en/18.0.0/docs/examples/receiving-zmq-notifications.html#javascript-example'\\\" />\\n<style></style>\"\n}\n[/block]\nThe following Python example is found in the [Dash Core repository](https://github.com/dashpay/dash/blob/master/contrib/zmq/zmq_sub3.4.py):\n\n```python\n#!/usr/bin/env python3\n# Copyright (c) 2014-2016 The Bitcoin Core developers\n# Distributed under the MIT software license, see the accompanying\n# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n\"\"\"\n    ZMQ example using python3's asyncio\n\n    Dash should be started with the command line arguments:\n        dashd -testnet -daemon \\\n                -zmqpubrawtx=tcp://127.0.0.1:28332 \\\n                -zmqpubrawblock=tcp://127.0.0.1:28332 \\\n                -zmqpubhashtx=tcp://127.0.0.1:28332 \\\n                -zmqpubhashblock=tcp://127.0.0.1:28332\n\n    We use the asyncio library here.  `self.handle()` installs itself as a\n    future at the end of the function.  Since it never returns with the event\n    loop having an empty stack of futures, this creates an infinite loop.  An\n    alternative is to wrap the contents of `handle` inside `while True`.\n\n    The `@asyncio.coroutine` decorator and the `yield from` syntax found here\n    was introduced in python 3.4 and has been deprecated in favor of the `async`\n    and `await` keywords respectively.\n\n    A blocking example using python 2.7 can be obtained from the git history:\n    https://github.com/bitcoin/bitcoin/blob/37a7fe9e440b83e2364d5498931253937abe9294/contrib/zmq/zmq_sub.py\n\"\"\"\n\nimport binascii\nimport asyncio\nimport zmq\nimport zmq.asyncio\nimport signal\nimport struct\nimport sys\n\nif not (sys.version_info.major >= 3 and sys.version_info.minor >= 4):\n    print(\"This example only works with Python 3.4 and greater\")\n    exit(1)\n\nport = 28332\n\nclass ZMQHandler():\n    def __init__(self):\n        self.loop = asyncio.get_event_loop()\n        self.zmqContext = zmq.asyncio.Context()\n\n        self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashchainlock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtxlock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashgovernancevote\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashgovernanceobject\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashinstantsenddoublespend\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawblock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawchainlock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawchainlocksig\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawtx\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawtxlock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawtxlocksig\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawgovernancevote\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawgovernanceobject\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawinstantsenddoublespend\")\n        self.zmqSubSocket.connect(\"tcp://127.0.0.1:%i\" % port)\n\n    @asyncio.coroutine\n    def handle(self) :\n        msg = yield from self.zmqSubSocket.recv_multipart()\n        topic = msg[0]\n        body = msg[1]\n        sequence = \"Unknown\"\n        if len(msg[-1]) == 4:\n          msgSequence = struct.unpack('<I', msg[-1])[-1]\n          sequence = str(msgSequence)\n        if topic == b\"hashblock\":\n            print('- HASH BLOCK ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashchainlock\":\n            print('- HASH CHAINLOCK ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashtx\":\n            print ('- HASH TX ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashtxlock\":\n            print('- HASH TX LOCK ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashgovernancevote\":\n            print('- HASH GOVERNANCE VOTE ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashgovernanceobject\":\n            print('- HASH GOVERNANCE OBJECT ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashinstantsenddoublespend\":\n            print('- HASH IS DOUBLE SPEND ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawblock\":\n            print('- RAW BLOCK HEADER ('+sequence+') -')\n            print(binascii.hexlify(body[:80]).decode(\"utf-8\"))\n        elif topic == b\"rawchainlock\":\n            print('- RAW CHAINLOCK ('+sequence+') -')\n            print(binascii.hexlify(body[:80]).decode(\"utf-8\"))\n        elif topic == b\"rawchainlocksig\":\n            print('- RAW CHAINLOCK SIG ('+sequence+') -')\n            print(binascii.hexlify(body[:80]).decode(\"utf-8\"))\n        elif topic == b\"rawtx\":\n            print('- RAW TX ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawtxlock\":\n            print('- RAW TX LOCK ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawtxlocksig\":\n            print('- RAW TX LOCK SIG ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawgovernancevote\":\n            print('- RAW GOVERNANCE VOTE ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawgovernanceobject\":\n            print('- RAW GOVERNANCE OBJECT ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawinstantsenddoublespend\":\n            print('- RAW IS DOUBLE SPEND ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        # schedule ourselves to receive the next message\n        asyncio.ensure_future(self.handle())\n\n    def start(self):\n        self.loop.add_signal_handler(signal.SIGINT, self.stop)\n        self.loop.create_task(self.handle())\n        self.loop.run_forever()\n\n    def stop(self):\n        self.loop.stop()\n        self.zmqContext.destroy()\n\ndaemon = ZMQHandler()\ndaemon.start()\n```",
 "order": 0,
 "isReference": false,
 "deprecated": false,
 "hidden": true,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "reusableContent": [],
 "previousSlug": "",
 "slugUpdatedAt": "2023-01-24T20:30:57.650Z",
 "revision": 10,
 "_id": "63f5176df91c7700118e7817",
 "pendingAlgoliaPublish": false,
 "createdAt": "2020-05-13T14:44:00.426Z",
 "updatedAt": "2023-01-24T21:06:59.075Z",
 "user": "5b8400d7185d5e00036dcc3b",
 "parentDoc": "63f5176df91c7700118e7816",
 "category": "63f5176df91c7700118e77a1",
 "project": "5daf2e65f4109c0040fd51e1",
 "version": "63f5176df91c7700118e7825",
 "__v": 0,
 "isApi": false,
 "id": "63f5176df91c7700118e7817",
 "body_html": "> \ud83d\udea7 New site!\n>\n> All content has been migrated to docs.dash.org. You will be automatically redirected momentarily.\n[block:html]\n{\n  \"html\": \"<div></div>\\n<meta http-equiv=\\\"refresh\\\" content=\\\"2; url='https://dash-user-docs.readthedocs.io/projects/core/en/18.0.0/docs/examples/receiving-zmq-notifications.html#javascript-example'\\\" />\\n<style></style>\"\n}\n[/block]\nThe following Python example is found in the [Dash Core repository](https://github.com/dashpay/dash/blob/master/contrib/zmq/zmq_sub3.4.py):\n\n```python\n#!/usr/bin/env python3\n# Copyright (c) 2014-2016 The Bitcoin Core developers\n# Distributed under the MIT software license, see the accompanying\n# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n\"\"\"\n    ZMQ example using python3's asyncio\n\n    Dash should be started with the command line arguments:\n        dashd -testnet -daemon \\\n                -zmqpubrawtx=tcp://127.0.0.1:28332 \\\n                -zmqpubrawblock=tcp://127.0.0.1:28332 \\\n                -zmqpubhashtx=tcp://127.0.0.1:28332 \\\n                -zmqpubhashblock=tcp://127.0.0.1:28332\n\n    We use the asyncio library here.  `self.handle()` installs itself as a\n    future at the end of the function.  Since it never returns with the event\n    loop having an empty stack of futures, this creates an infinite loop.  An\n    alternative is to wrap the contents of `handle` inside `while True`.\n\n    The `@asyncio.coroutine` decorator and the `yield from` syntax found here\n    was introduced in python 3.4 and has been deprecated in favor of the `async`\n    and `await` keywords respectively.\n\n    A blocking example using python 2.7 can be obtained from the git history:\n    https://github.com/bitcoin/bitcoin/blob/37a7fe9e440b83e2364d5498931253937abe9294/contrib/zmq/zmq_sub.py\n\"\"\"\n\nimport binascii\nimport asyncio\nimport zmq\nimport zmq.asyncio\nimport signal\nimport struct\nimport sys\n\nif not (sys.version_info.major >= 3 and sys.version_info.minor >= 4):\n    print(\"This example only works with Python 3.4 and greater\")\n    exit(1)\n\nport = 28332\n\nclass ZMQHandler():\n    def __init__(self):\n        self.loop = asyncio.get_event_loop()\n        self.zmqContext = zmq.asyncio.Context()\n\n        self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashchainlock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtxlock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashgovernancevote\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashgovernanceobject\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"hashinstantsenddoublespend\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawblock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawchainlock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawchainlocksig\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawtx\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawtxlock\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawtxlocksig\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawgovernancevote\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawgovernanceobject\")\n        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, \"rawinstantsenddoublespend\")\n        self.zmqSubSocket.connect(\"tcp://127.0.0.1:%i\" % port)\n\n    @asyncio.coroutine\n    def handle(self) :\n        msg = yield from self.zmqSubSocket.recv_multipart()\n        topic = msg[0]\n        body = msg[1]\n        sequence = \"Unknown\"\n        if len(msg[-1]) == 4:\n          msgSequence = struct.unpack('<I', msg[-1])[-1]\n          sequence = str(msgSequence)\n        if topic == b\"hashblock\":\n            print('- HASH BLOCK ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashchainlock\":\n            print('- HASH CHAINLOCK ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashtx\":\n            print ('- HASH TX ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashtxlock\":\n            print('- HASH TX LOCK ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashgovernancevote\":\n            print('- HASH GOVERNANCE VOTE ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashgovernanceobject\":\n            print('- HASH GOVERNANCE OBJECT ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"hashinstantsenddoublespend\":\n            print('- HASH IS DOUBLE SPEND ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawblock\":\n            print('- RAW BLOCK HEADER ('+sequence+') -')\n            print(binascii.hexlify(body[:80]).decode(\"utf-8\"))\n        elif topic == b\"rawchainlock\":\n            print('- RAW CHAINLOCK ('+sequence+') -')\n            print(binascii.hexlify(body[:80]).decode(\"utf-8\"))\n        elif topic == b\"rawchainlocksig\":\n            print('- RAW CHAINLOCK SIG ('+sequence+') -')\n            print(binascii.hexlify(body[:80]).decode(\"utf-8\"))\n        elif topic == b\"rawtx\":\n            print('- RAW TX ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawtxlock\":\n            print('- RAW TX LOCK ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawtxlocksig\":\n            print('- RAW TX LOCK SIG ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawgovernancevote\":\n            print('- RAW GOVERNANCE VOTE ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawgovernanceobject\":\n            print('- RAW GOVERNANCE OBJECT ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        elif topic == b\"rawinstantsenddoublespend\":\n            print('- RAW IS DOUBLE SPEND ('+sequence+') -')\n            print(binascii.hexlify(body).decode(\"utf-8\"))\n        # schedule ourselves to receive the next message\n        asyncio.ensure_future(self.handle())\n\n    def start(self):\n        self.loop.add_signal_handler(signal.SIGINT, self.stop)\n        self.loop.create_task(self.handle())\n        self.loop.run_forever()\n\n    def stop(self):\n        self.loop.stop()\n        self.zmqContext.destroy()\n\ndaemon = ZMQHandler()\ndaemon.start()\n```"
}