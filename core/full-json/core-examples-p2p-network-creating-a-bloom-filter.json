{
 "metadata": {
  "image": [],
  "title": "Creating A Bloom Filter",
  "description": "In this section, we'll use variable names that correspond to the field names in the filterload message documentation.",
  "keywords": "",
  "robots": "index"
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "status": 200,
     "language": "json",
     "code": "{}",
     "name": ""
    },
    {
     "status": 400,
     "language": "json",
     "code": "{}",
     "name": ""
    }
   ]
  },
  "params": []
 },
 "next": {
  "description": "",
  "pages": [
   {
    "type": "doc",
    "icon": "file-text-o",
    "name": "Evaluating A Bloom Filter",
    "slug": "core-examples-p2p-network-evaluating-a-bloom-filter",
    "category": "Core Examples"
   }
  ]
 },
 "algolia": {
  "recordCount": 1,
  "publishPending": false,
  "translationFailure": false,
  "updatedAt": "2023-02-21T19:15:49.333Z"
 },
 "title": "Creating A Bloom Filter",
 "icon": "",
 "updates": [],
 "type": "basic",
 "slug": "core-examples-p2p-network-creating-a-bloom-filter",
 "excerpt": "",
 "body": "In this section, we'll use variable names that correspond to the field names in the [`filterload` message documentation](core-ref-p2p-network-control-messages#filterload). Each code block precedes the paragraph describing it.\n\n``` python\n#!/usr/bin/env python\n\nBYTES_MAX = 36000\nFUNCS_MAX = 50\n\nnFlags = 0\n```\n\nWe start by setting some maximum values defined in [BIP37](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki): the maximum number of bytes allowed in a filter and the maximum number of hash functions used to hash each piece of data.  We also set nFlags to zero, indicating we don't want the remote node to update the filter for us. (We won't use nFlags again in the sample program, but real programs will need to use it.)\n\n``` python\nn = 1\np = 0.0001\n```\n\nWe define the number (n) of elements we plan to insert into the filter and the false positive rate (p) we want to help protect our privacy. For this example, we will set *n* to one element and *p* to a rate of 1-in-10,000 to produce a small and precise filter for illustration purposes. In actual use, your filters will probably be much larger.\n\n``` python\nfrom math import log\nnFilterBytes = int(min((-1 / log(2)**2 * n * log(p)) / 8, BYTES_MAX))\nnHashFuncs = int(min(nFilterBytes * 8 / n * log(2), FUNCS_MAX))\n\nfrom bitarray import bitarray  # from pypi.python.org/pypi/bitarray\nvData = nFilterBytes * 8 * bitarray('0', endian=\"little\")\n```\n\nUsing the formula described in [BIP37](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki), we calculate the ideal size of the filter (in bytes) and the ideal number of hash functions to use. Both are truncated down to the nearest whole number and both are also constrained to the maximum values we defined earlier. The results of this particular fixed computation are 2 filter bytes and 11 hash functions. We then use *nFilterBytes* to create a little-endian bit array of the appropriate size.\n\n``` python\nnTweak = 0\n```\n\nWe also should choose a value for *nTweak*.  In this case, we'll simply use zero.\n\n``` python\nimport pyhash  # from https://github.com/flier/pyfasthash\nmurmur3 = pyhash.murmur3_32()\n\ndef bloom_hash(nHashNum, data):\n    seed = (nHashNum * 0xfba4c795 + nTweak) & 0xffffffff\n    return( murmur3(data, seed=seed) % (nFilterBytes * 8) )\n```\n\nWe setup our hash function template using the formula and 0xfba4c795 constant set in [BIP37](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki). Note that we limit the size of the seed to four bytes and that we're returning the result of the hash modulo the size of the filter in bits.\n\n``` python\ndata_to_hash = \"019f5b01d4195ecbc9398fbf3c3b1fa9\" \\\n               + \"bb3183301d7a1fb3bd174fcfa40a2b65\"\ndata_to_hash = data_to_hash.decode(\"hex\")\n```\n\nFor the data to add to the filter, we're adding a <<glossary:TXID>>. Note that the TXID is in <<glossary:internal byte order>>.\n\n``` python\nprint \"                             Filter (As Bits)\"\nprint \"nHashNum   nIndex   Filter   0123456789abcdef\"\nprint \"~~~~~~~~   ~~~~~~   ~~~~~~   ~~~~~~~~~~~~~~~~\"\nfor nHashNum in range(nHashFuncs):\n    nIndex = bloom_hash(nHashNum, data_to_hash)\n\n    ## Set the bit at nIndex to 1\n    vData[nIndex] = True\n\n    ## Debug: print current state\n    print '      {0:2}      {1:2}     {2}   {3}'.format(\n        nHashNum,\n        hex(int(nIndex)),\n        vData.tobytes().encode(\"hex\"),\n        vData.to01()\n    )\n\nprint\nprint \"Bloom filter:\", vData.tobytes().encode(\"hex\")\n```\n\nNow we use the hash function template to run a slightly different hash function for *nHashFuncs* times. The result of each function being run on the transaction is used as an index number: the bit at that index is set to 1. We can see this in the printed debugging output:\n\n``` text\n                             Filter (As Bits)\nnHashNum   nIndex   Filter   0123456789abcdef\n~~~~~~~~   ~~~~~~   ~~~~~~   ~~~~~~~~~~~~~~~~\n       0      0x7     8000   0000000100000000\n       1      0x9     8002   0000000101000000\n       2      0xa     8006   0000000101100000\n       3      0x2     8406   0010000101100000\n       4      0xb     840e   0010000101110000\n       5      0x5     a40e   0010010101110000\n       6      0x0     a50e   1010010101110000\n       7      0x8     a50f   1010010111110000\n       8      0x5     a50f   1010010111110000\n       9      0x8     a50f   1010010111110000\n      10      0x4     b50f   1010110111110000\n\nBloom filter: b50f\n```\n\nNotice that in iterations 8 and 9, the filter did not change because the corresponding bit was already set in a previous iteration (5 and 7, respectively).  This is a normal part of <<glossary:bloom filter>> operation.\n\nWe only added one element to the filter above, but we could repeat the process with additional elements and continue to add them to the same filter. (To maintain the same false-positive rate, you would need a larger filter size as computed earlier.)\n\nNote: for a more optimized Python implementation with fewer external dependencies, see [python-bitcoinlib's](https://github.com/petertodd/python-bitcoinlib) bloom filter module which is based directly on Bitcoin Core's C++ implementation.\n\nUsing the [`filterload` message](core-ref-p2p-network-control-messages#filterload) format, the complete filter created above would be the binary form of the annotated hexdump shown below:\n\n``` text\n02 ......... Filter bytes: 2\nb50f ....... Filter: 1010 1101 1111 0000\n0b000000 ... nHashFuncs: 11\n00000000 ... nTweak: 0/none\n00 ......... nFlags: BLOOM_UPDATE_NONE\n```",
 "order": 0,
 "isReference": false,
 "deprecated": false,
 "hidden": false,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "reusableContent": [],
 "previousSlug": "",
 "slugUpdatedAt": "2022-09-20T18:32:50.702Z",
 "revision": 2,
 "_id": "63f5176df91c7700118e77d1",
 "version": "63f5176df91c7700118e7825",
 "updatedAt": "2020-05-28T20:29:11.461Z",
 "createdAt": "2019-10-24T14:51:15.932Z",
 "project": "5daf2e65f4109c0040fd51e1",
 "user": "62b2101422da70001ee51d95",
 "parentDoc": "63f5176df91c7700118e77cb",
 "category": "63f5176df91c7700118e77a0",
 "__v": 1,
 "pendingAlgoliaPublish": false,
 "isApi": false,
 "id": "63f5176df91c7700118e77d1",
 "body_html": "<p>In this section, we&#x27;ll use variable names that correspond to the field names in the <a href=\"core-ref-p2p-network-control-messages#filterload\" target=\"\" title=\"\"><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">filterload</code> message documentation</a>. Each code block precedes the paragraph describing it.</p>\n<div class=\"CodeTabs CodeTabs_initial theme-light\"><div class=\"CodeTabs-toolbar\" role=\"tablist\"><button aria-selected=\"true\" class=\"CodeTabs_active\" role=\"tab\" type=\"button\">Python</button></div><div class=\"CodeTabs-inner\" role=\"tabpanel\"><pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang-python theme-light\" data-lang=\"python\" name=\"\" tabindex=\"0\">#!/usr/bin/env python\n\nBYTES_MAX = 36000\nFUNCS_MAX = 50\n\nnFlags = 0\n</code></pre></div></div>\n<p>We start by setting some maximum values defined in <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki\" target=\"\" title=\"\">BIP37</a>: the maximum number of bytes allowed in a filter and the maximum number of hash functions used to hash each piece of data.  We also set nFlags to zero, indicating we don&#x27;t want the remote node to update the filter for us. (We won&#x27;t use nFlags again in the sample program, but real programs will need to use it.)</p>\n<div class=\"CodeTabs CodeTabs_initial theme-light\"><div class=\"CodeTabs-toolbar\" role=\"tablist\"><button aria-selected=\"true\" class=\"CodeTabs_active\" role=\"tab\" type=\"button\">Python</button></div><div class=\"CodeTabs-inner\" role=\"tabpanel\"><pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang-python theme-light\" data-lang=\"python\" name=\"\" tabindex=\"0\">n = 1\np = 0.0001\n</code></pre></div></div>\n<p>We define the number (n) of elements we plan to insert into the filter and the false positive rate (p) we want to help protect our privacy. For this example, we will set <em>n</em> to one element and <em>p</em> to a rate of 1-in-10,000 to produce a small and precise filter for illustration purposes. In actual use, your filters will probably be much larger.</p>\n<div class=\"CodeTabs CodeTabs_initial theme-light\"><div class=\"CodeTabs-toolbar\" role=\"tablist\"><button aria-selected=\"true\" class=\"CodeTabs_active\" role=\"tab\" type=\"button\">Python</button></div><div class=\"CodeTabs-inner\" role=\"tabpanel\"><pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang-python theme-light\" data-lang=\"python\" name=\"\" tabindex=\"0\">from math import log\nnFilterBytes = int(min((-1 / log(2)**2 * n * log(p)) / 8, BYTES_MAX))\nnHashFuncs = int(min(nFilterBytes * 8 / n * log(2), FUNCS_MAX))\n\nfrom bitarray import bitarray  # from pypi.python.org/pypi/bitarray\nvData = nFilterBytes * 8 * bitarray(&#x27;0&#x27;, endian=&quot;little&quot;)\n</code></pre></div></div>\n<p>Using the formula described in <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki\" target=\"\" title=\"\">BIP37</a>, we calculate the ideal size of the filter (in bytes) and the ideal number of hash functions to use. Both are truncated down to the nearest whole number and both are also constrained to the maximum values we defined earlier. The results of this particular fixed computation are 2 filter bytes and 11 hash functions. We then use <em>nFilterBytes</em> to create a little-endian bit array of the appropriate size.</p>\n<div class=\"CodeTabs CodeTabs_initial theme-light\"><div class=\"CodeTabs-toolbar\" role=\"tablist\"><button aria-selected=\"true\" class=\"CodeTabs_active\" role=\"tab\" type=\"button\">Python</button></div><div class=\"CodeTabs-inner\" role=\"tabpanel\"><pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang-python theme-light\" data-lang=\"python\" name=\"\" tabindex=\"0\">nTweak = 0\n</code></pre></div></div>\n<p>We also should choose a value for <em>nTweak</em>.  In this case, we&#x27;ll simply use zero.</p>\n<div class=\"CodeTabs CodeTabs_initial theme-light\"><div class=\"CodeTabs-toolbar\" role=\"tablist\"><button aria-selected=\"true\" class=\"CodeTabs_active\" role=\"tab\" type=\"button\">Python</button></div><div class=\"CodeTabs-inner\" role=\"tabpanel\"><pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang-python theme-light\" data-lang=\"python\" name=\"\" tabindex=\"0\">import pyhash  # from https://github.com/flier/pyfasthash\nmurmur3 = pyhash.murmur3_32()\n\ndef bloom_hash(nHashNum, data):\n    seed = (nHashNum * 0xfba4c795 + nTweak) &amp; 0xffffffff\n    return( murmur3(data, seed=seed) % (nFilterBytes * 8) )\n</code></pre></div></div>\n<p>We setup our hash function template using the formula and 0xfba4c795 constant set in <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki\" target=\"\" title=\"\">BIP37</a>. Note that we limit the size of the seed to four bytes and that we&#x27;re returning the result of the hash modulo the size of the filter in bits.</p>\n<div class=\"CodeTabs CodeTabs_initial theme-light\"><div class=\"CodeTabs-toolbar\" role=\"tablist\"><button aria-selected=\"true\" class=\"CodeTabs_active\" role=\"tab\" type=\"button\">Python</button></div><div class=\"CodeTabs-inner\" role=\"tabpanel\"><pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang-python theme-light\" data-lang=\"python\" name=\"\" tabindex=\"0\">data_to_hash = &quot;019f5b01d4195ecbc9398fbf3c3b1fa9&quot; \\\n               + &quot;bb3183301d7a1fb3bd174fcfa40a2b65&quot;\ndata_to_hash = data_to_hash.decode(&quot;hex&quot;)\n</code></pre></div></div>\n<p>For the data to add to the filter, we&#x27;re adding a <span class=\"GlossaryItem-trigger\">TXID</span>. Note that the TXID is in <span class=\"GlossaryItem-trigger\">internal byte order</span>.</p>\n<div class=\"CodeTabs CodeTabs_initial theme-light\"><div class=\"CodeTabs-toolbar\" role=\"tablist\"><button aria-selected=\"true\" class=\"CodeTabs_active\" role=\"tab\" type=\"button\">Python</button></div><div class=\"CodeTabs-inner\" role=\"tabpanel\"><pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang-python theme-light\" data-lang=\"python\" name=\"\" tabindex=\"0\">print &quot;                             Filter (As Bits)&quot;\nprint &quot;nHashNum   nIndex   Filter   0123456789abcdef&quot;\nprint &quot;~~~~~~~~   ~~~~~~   ~~~~~~   ~~~~~~~~~~~~~~~~&quot;\nfor nHashNum in range(nHashFuncs):\n    nIndex = bloom_hash(nHashNum, data_to_hash)\n\n    ## Set the bit at nIndex to 1\n    vData[nIndex] = True\n\n    ## Debug: print current state\n    print &#x27;      {0:2}      {1:2}     {2}   {3}&#x27;.format(\n        nHashNum,\n        hex(int(nIndex)),\n        vData.tobytes().encode(&quot;hex&quot;),\n        vData.to01()\n    )\n\nprint\nprint &quot;Bloom filter:&quot;, vData.tobytes().encode(&quot;hex&quot;)\n</code></pre></div></div>\n<p>Now we use the hash function template to run a slightly different hash function for <em>nHashFuncs</em> times. The result of each function being run on the transaction is used as an index number: the bit at that index is set to 1. We can see this in the printed debugging output:</p>\n<div class=\"CodeTabs CodeTabs_initial theme-light\"><div class=\"CodeTabs-toolbar\" role=\"tablist\"><button aria-selected=\"true\" class=\"CodeTabs_active\" role=\"tab\" type=\"button\">Text</button></div><div class=\"CodeTabs-inner\" role=\"tabpanel\"><pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang-text theme-light\" data-lang=\"text\" name=\"\" tabindex=\"0\">                             Filter (As Bits)\nnHashNum   nIndex   Filter   0123456789abcdef\n~~~~~~~~   ~~~~~~   ~~~~~~   ~~~~~~~~~~~~~~~~\n       0      0x7     8000   0000000100000000\n       1      0x9     8002   0000000101000000\n       2      0xa     8006   0000000101100000\n       3      0x2     8406   0010000101100000\n       4      0xb     840e   0010000101110000\n       5      0x5     a40e   0010010101110000\n       6      0x0     a50e   1010010101110000\n       7      0x8     a50f   1010010111110000\n       8      0x5     a50f   1010010111110000\n       9      0x8     a50f   1010010111110000\n      10      0x4     b50f   1010110111110000\n\nBloom filter: b50f\n</code></pre></div></div>\n<p>Notice that in iterations 8 and 9, the filter did not change because the corresponding bit was already set in a previous iteration (5 and 7, respectively).  This is a normal part of <span class=\"GlossaryItem-trigger\">bloom filter</span> operation.</p>\n<p>We only added one element to the filter above, but we could repeat the process with additional elements and continue to add them to the same filter. (To maintain the same false-positive rate, you would need a larger filter size as computed earlier.)</p>\n<p>Note: for a more optimized Python implementation with fewer external dependencies, see <a href=\"https://github.com/petertodd/python-bitcoinlib\" target=\"\" title=\"\">python-bitcoinlib&#x27;s</a> bloom filter module which is based directly on Bitcoin Core&#x27;s C++ implementation.</p>\n<p>Using the <a href=\"core-ref-p2p-network-control-messages#filterload\" target=\"\" title=\"\"><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">filterload</code> message</a> format, the complete filter created above would be the binary form of the annotated hexdump shown below:</p>\n<div class=\"CodeTabs CodeTabs_initial theme-light\"><div class=\"CodeTabs-toolbar\" role=\"tablist\"><button aria-selected=\"true\" class=\"CodeTabs_active\" role=\"tab\" type=\"button\">Text</button></div><div class=\"CodeTabs-inner\" role=\"tabpanel\"><pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang-text theme-light\" data-lang=\"text\" name=\"\" tabindex=\"0\">02 ......... Filter bytes: 2\nb50f ....... Filter: 1010 1101 1111 0000\n0b000000 ... nHashFuncs: 11\n00000000 ... nTweak: 0/none\n00 ......... nFlags: BLOOM_UPDATE_NONE\n</code></pre></div></div>"
}