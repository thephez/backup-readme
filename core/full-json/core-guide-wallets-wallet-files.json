{
 "metadata": {
  "image": [],
  "title": "Wallet Files",
  "description": "Dash wallets at their core are a collection of private keys. These collections are stored digitally in a file, or can even be physically stored on pieces of paper.",
  "keywords": "",
  "robots": "index"
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "status": 200,
     "language": "json",
     "code": "{}",
     "name": ""
    },
    {
     "status": 400,
     "language": "json",
     "code": "{}",
     "name": ""
    }
   ]
  },
  "params": []
 },
 "next": {
  "description": "",
  "pages": [
   {
    "type": "doc",
    "icon": "file-text-o",
    "name": "Operating Modes",
    "slug": "core-guide-operating-modes",
    "category": "Core Guides"
   }
  ]
 },
 "algolia": {
  "recordCount": 9,
  "publishPending": false,
  "translationFailure": false,
  "updatedAt": "2023-02-21T19:16:05.950Z"
 },
 "title": "Wallet Files",
 "icon": "",
 "updates": [],
 "type": "basic",
 "slug": "core-guide-wallets-wallet-files",
 "excerpt": "",
 "body": "Dash wallets at their core are a collection of <<glossary:private keys>>. These collections are stored digitally in a file, or can even be physically stored on pieces of paper.\n\n# Private Key Formats\n\nPrivate keys are what are used to unlock <<glossary:duffs>> from a particular <<glossary:address>>. In Dash, a private key in standard format is simply a 256-bit number, between the values:\n\n`0x01` and `0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140`, representing nearly the entire range of 2<sup>256</sup>-1 values. The range is governed by the secp256k1 ECDSA encryption standard used by Dash.\n\n## Wallet Import Format (WIF)\n\nIn order to make copying of private keys less prone to error, <<glossary:Wallet Import Format>> may be utilized. WIF uses <<glossary:base58check>> encoding on a private key, greatly decreasing the chance of copying error, much like standard Dash <<glossary:addresses>>.\n\n1. Take a private key.\n\n2. Add a `0xCC` byte in front of it for <<glossary:mainnet>> addresses or `0xEF` for <<glossary:testnet>> addresses.\n\n3. Append a `0x01` byte after it if it should be used with compressed public keys (described in a later subsection). Nothing is appended if it is used with uncompressed public keys.\n\n4. Perform a SHA-256 hash on the <<glossary:extended key>>.\n\n5. Perform a SHA-256 hash on result of SHA-256 hash.\n\n6. Take the first four bytes of the second SHA-256 hash; this is the checksum.\n\n7. Add the four checksum bytes from point 5 at the end of the extended key from point 2.\n\n8. Convert the result from a byte string into a Base58 string using Base58Check encoding.\n\nThe process is easily reversible, using the Base58 decoding function, and removing the padding.\n\n## Mini Private Key Format\n\nMini private key format is a method for encoding a private key in under 30 characters, enabling keys to be embedded in a small physical space and more damage-resistant QR codes.\n\n1. The first character of mini keys is '`S`'.\n\n2. In order to determine if a mini private key is well-formatted, a question mark is added to the private key.\n\n3. The SHA256 hash is calculated. If the first byte produced is a `00`, it is well-formatted. This key restriction acts as a typo-checking mechanism. A user brute forces the process using random numbers until a well-formatted mini private key is produced.\n\n4. In order to derive the full private key, the user simply takes a single SHA256 hash of the original mini private key. This process is one-way: it is intractable to compute the mini private key format from the derived key.\n\nMany implementations disallow the character '1' in the mini private key due to its visual similarity to 'l'.\n\n**Resource:** A common tool to create and redeem these keys is the [Casascius Bitcoin Address Utility](https://github.com/casascius/Bitcoin-Address-Utility). Note: this tool is no longer actively developed.\n\n# Public Key Formats\n\nDash ECDSA public keys represent a point on a particular Elliptic Curve (EC) defined in secp256k1. In their traditional uncompressed form, public keys contain an identification byte, a 32-byte X coordinate, and a 32-byte Y coordinate. The extremely simplified illustration below shows such a point on the elliptic curve used by Dash, y<sup>2</sup>&nbsp;=&nbsp;x<sup>3</sup>&nbsp;+&nbsp;7, over a field of contiguous numbers.\n\n![Point On ECDSA Curve](https://dash-docs.github.io/img/dev/en-ecdsa-compressed-public-key.svg)\n\n(Secp256k1 actually modulos coordinates by a large prime, which produces a field of non-contiguous integers and a significantly less clear plot, although the principles are the same.)\n\nAn almost 50% reduction in <<glossary:public key>> size can be realized without changing any fundamentals by dropping the Y coordinate. This is possible because only two points along the curve share any particular X coordinate, so the 32-byte Y coordinate can be replaced with a single bit indicating whether the point is on what appears in the illustration as the \"top\" side or the \"bottom\" side.\n\nNo data is lost by creating a <<glossary:compressed public key>>---only a small amount of CPU is necessary to reconstruct the Y coordinate and access the uncompressed public key. Both uncompressed and compressed public keys are described in official secp256k1 documentation and supported by default in the widely-used OpenSSL library.\n\nBecause they're easy to use, and because they reduce almost by half the <<glossary:block chain>> space used to store public keys for every spent <<glossary:output>>, compressed public keys are the default in Dash Core and are the recommended default for all Dash software.\n\nHowever, Bitcoin Core prior to 0.6 used uncompressed keys.  This creates a few complications, as the hashed form of an uncompressed key is different than the hashed form of a compressed key, so the same key works with two different <<glossary:P2PKH>> addresses.   This also means that the key must be submitted in the correct format in the <<glossary:signature script>> so it matches the hash in the previous output's pubkey script.\n\nFor this reason, Bitcoin Core (and Dash Core) uses several different identifier bytes to help programs identify how keys should be used:\n\n* Private keys meant to be used with compressed public keys have 0x01 appended to them before being Base-58 encoded. (See the private key encoding section above.)\n\n* Uncompressed public keys start with 0x04; compressed public keys begin with 0x03 or 0x02 depending on whether they're greater or less than the midpoint of the curve.  These prefix bytes are all used in official secp256k1 documentation.\n\n# Hierarchical Deterministic Key Creation\n\nThe hierarchical deterministic key creation and transfer protocol (<<glossary:HD protocol>>) greatly simplifies wallet backups, eliminates the need for repeated communication between multiple programs using the same wallet, permits creation of child accounts which can operate independently, gives each parent account the ability to monitor or control its children even if the child account is compromised, and divides each account into full-access and restricted-access parts so untrusted users or programs can be allowed to receive or monitor payments without being able to spend them.\n\nThe HD protocol takes advantage of the ECDSA public key creation function, `<<glossary:point>>()`, which takes a large integer (the private key) and turns it into a graph point (the public key):\n\n    point(private_key) == public_key\n\nBecause of the way `point()` works, it's possible to create a <<glossary:child public key>> by combining an existing <<glossary:parent public key>> with another public key created from any integer (*i*) value. This child public key is the same public key which would be created by the `point()` function if you added the *i* value to the original (parent) private key and then found the remainder of that sum divided by a global constant used by all Dash software (*p*):\n\n    point( (parent_private_key + i) % p ) == parent_public_key + point(i)\n\nThis means that two or more independent programs which agree on a sequence of integers can create a series of unique <<glossary:child key>> pairs from a single <<glossary:parent key>> pair without any further communication. Moreover, the program which distributes new public keys for receiving payment can do so without any access to the private keys, allowing the public key distribution program to run on a possibly-insecure platform such as a public web server.\n\nChild public keys can also create their own child public keys (grandchild public keys) by repeating the child key derivation operations:\n\n    point( (child_private_key + i) % p ) == child_public_key + point(i)\n\nWhether creating child public keys or further-descended public keys, a predictable sequence of integer values would be no better than using a single public key for all transactions, as anyone who knew one child public key could find all of the other child public keys created from the same parent public key. Instead, a random seed can be used to deterministically generate the sequence of integer values so that the relationship between the child public keys is invisible to anyone without that seed.\n\nThe HD protocol uses a single <<glossary:root seed>> to create a hierarchy of child, grandchild, and other descended keys with unlinkable deterministically-generated integer values. Each child key also gets a deterministically-generated seed from its parent, called a <<glossary:chain code>>, so the compromising of one chain code doesn't necessarily compromise the integer sequence for the whole hierarchy, allowing the <<glossary:master chain code>> to continue being useful even if, for example, a web-based public key distribution program gets hacked.\n\n![Overview Of Hierarchical Deterministic Key Derivation](https://dash-docs.github.io/img/dev/en-hd-overview.svg)\n\nAs illustrated above, HD key derivation takes four inputs:\n\n* The *<<glossary:parent private key>>* and *<<glossary:parent public key>>* are regular uncompressed 256-bit ECDSA keys.\n\n* The <<glossary:parent chain code>> is 256 bits of seemingly-random data.\n\n* The <<glossary:index>> number is a 32-bit integer specified by the program.\n\nIn the normal form shown in the above illustration, the <<glossary:parent chain code>>, the parent public key, and the index number are fed into a one-way cryptographic hash ([HMAC-SHA512](https://en.wikipedia.org/wiki/HMAC)) to produce 512 bits of deterministically-generated-but-seemingly-random data. The seemingly-random 256 bits on the right-hand side of the hash output are used as a new child chain code. The seemingly-random 256 bits on the left-hand side of the hash output are used as the integer value to be combined with either the parent private key or parent public key to, respectively, create either a child private key or child public key:\n\n```\nchild_private_key == (parent_private_key + lefthand_hash_output) % G \nchild_public_key == point( (parent_private_key + lefthand_hash_output) % G ) \nchild_public_key == point(child_private_key) == parent_public_key + point(lefthand_hash_output)\n```\n\nSpecifying different index numbers will create different unlinkable child keys from the same parent keys.  Repeating the procedure for the child keys using the child chain code will create unlinkable grandchild keys.\n\nBecause creating child keys requires both a key and a chain code, the key and chain code together are called the <<glossary:extended key>>. An <<glossary:extended private key>> and its corresponding <<glossary:extended public key>> have the same chain code. The (top-level parent) <<glossary:master private key>> and master chain code are derived from random data, as illustrated below.\n\n![Creating A Root Extended Key Pair](https://dash-docs.github.io/img/dev/en-hd-root-keys.svg)\n\nA <<glossary:root seed>> is created from either 128 bits, 256 bits, or 512 bits of random data. This root seed of as little as 128 bits is the the only data the user needs to backup in order to derive every key created by a particular wallet program using particular settings.\n\n> \ud83d\udea7 HD Wallet Compatibility\n>\n> **Warning:** HD wallet programs are not always fully compatible, so users must only use the same HD wallet program with the same HD-related settings for a particular root seed.\n\nThe root seed is hashed to create 512 bits of seemingly-random data, from which the master private key and master chain code are created (together, the master extended private key). The master public key is derived from the master private key using `point()`, which, together with the master chain code, is the master extended public key. The master extended keys are functionally equivalent to other extended keys; it is only their location at the top of the hierarchy which makes them special.\n\n## Hardened Keys\n\nHardened extended keys fix a potential problem with normal extended keys. If an attacker gets a normal parent chain code and parent public key, he can brute-force all chain codes deriving from it. If the attacker also obtains a child, grandchild, or further-descended private key, he can use the chain code to generate all of the extended private keys descending from that private key, as shown in the grandchild and great-grandchild generations of the illustration below.\n\n![Cross-Generational Key Compromise](https://dash-docs.github.io/img/dev/en-hd-cross-generational-key-compromise.svg)\n\nPerhaps worse, the attacker can reverse the normal <<glossary:child private key>> derivation formula and subtract a <<glossary:parent chain code>> from a child private key to recover the <<glossary:parent private key>>, as shown in the child and parent generations of the illustration above.  This means an attacker who acquires an <<glossary:extended public key>> and any private key descended from it can recover that public key's private key and all keys descended from it.\n\nFor this reason, the <<glossary:chain code>> part of an extended public key should be better secured than standard public keys and users should be advised against exporting even non-extended private keys to possibly-untrustworthy environments.\n\nThis can be fixed, with some tradeoffs, by replacing the the normal key derivation formula with a hardened key derivation formula.\n\nThe normal key derivation formula, described in the section above, combines together the index number, the parent chain code, and the parent public key to create the child chain code and the integer value which is combined with the parent private key to create the child private key.\n\n![Creating Child Public Keys From An Extended Private Key](https://dash-docs.github.io/img/dev/en-hd-private-parent-to-private-child.svg)\n\nThe hardened formula, illustrated above, combines together the index number, the parent chain code, and the parent private key to create the data used to generate the child chain code and child private key. This formula makes it impossible to create child public keys without knowing the parent private key. In other words, parent extended public keys can't create hardened child public keys.\n\nBecause of that, a <<glossary:hardened extended private key>> is much less useful than a normal extended private key---however, hardened extended private keys create a firewall through which multi-level key derivation compromises cannot happen. Because hardened child extended public keys cannot generate grandchild chain codes on their own, the compromise of a parent extended public key cannot be combined with the compromise of a grandchild private key to create great-grandchild extended private keys.\n\nThe HD protocol uses different index numbers to indicate whether a normal or hardened key should be generated. Index numbers from `0x00` to `0x7fffffff` (0 to 2<sup>31</sup>-1) will generate a normal key; index numbers from `0x80000000` to `0xffffffff` will generate a hardened key. To make descriptions easy, many developers use the [prime symbol](https://en.wikipedia.org/wiki/Prime_%28symbol%29) to indicate hardened keys, so the first normal key (0x00) is 0 and the first hardened key (0x80000000) is 0\u00b4.\n\n> \ud83d\udcd8\n>\n> Dash developers typically use the ASCII apostrophe rather than the unicode prime symbol, a convention we will henceforth follow.\n\nThis compact description is further combined with slashes prefixed by *m* or *M* to indicate hierarchy and key type, with *m* being a private key and *M* being a public key. For example, m/0'/0/122' refers to the 123rd hardened private child (by index number) of the first normal child (by index) of the first hardened child (by index) of the master private key. The following hierarchy illustrates prime notation and hardened key firewalls.\n\n![Example HD Wallet Tree Using Prime Notation](https://dash-docs.github.io/img/dev/en-hd-tree.svg)\n\nWallets following the <<glossary:BIP32>> <<glossary:HD protocol>> only create hardened children of the master private key (*m*) to prevent a compromised child key from compromising the master key. As there are no normal children for the master keys, the master public key is not used in HD wallets. All other keys can have normal children, so the corresponding extended public keys may be used instead.\n\nThe HD protocol also describes a serialization format for extended public keys and extended private keys.  For details, please see the [wallet section in the developer reference](core-ref-wallets) or [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) for the full HD protocol specification.\n\n## Storing Root Seeds\n\nRoot seeds in the HD protocol are 128, 256, or 512 bits of random data which must be backed up precisely. To make it more convenient to use non-digital backup methods, such as memorization or hand-copying, [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) defines a method for creating a 512-bit root seed from a pseudo-sentence (mnemonic) of common natural-language words which was itself created from 128 to 256 bits of entropy and optionally protected by a password.\n\nThe number of words generated correlates to the amount of entropy used:\n\n| Entropy Bits |  Words |\n| --- | --- |\n|  128         |    12  |\n|  160         |    15  |\n|  192         |    18  |\n|  224         |    21  |\n|  256         |    24  |\n\nThe passphrase can be of any length.  It is simply appended to the mnemonic pseudo-sentence, and then both the mnemonic and password are hashed 2,048 times using HMAC-SHA512, resulting in a seemingly-random 512-bit seed.  Because any input to the hash function creates a seemingly-random 512-bit seed, there is no fundamental way to prove the user entered the correct password, possibly allowing the user to protect a seed even when under duress.\n\nFor implementation details, please see [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\n\n# Loose-Key Wallets\n\nLoose-Key wallets, also called \"Just a Bunch Of Keys (JBOK)\", are a form of wallet that originated from the Bitcoin Core client wallet. The Dash Core client wallet creates 1000 private key/public key pairs automatically via a Pseudo-Random-Number Generator (PRNG) for later use.\n\nThese unused private keys are stored in a virtual \"key pool\", with new keys being generated whenever a previously-generated key was used, ensuring the pool maintained 1000 unused keys. (If the wallet is encrypted, new keys are only generated while the wallet is unlocked.)\n\nThis creates considerable difficulty in backing up one\u2019s keys, considering backups have to be run manually to save the newly-generated private keys. If a new key pair set is generated, used, and then lost prior to a backup, the stored duffs are likely lost forever. Many older-style mobile wallets followed a similar format, but only generated a new private key upon user demand.\n\nThis wallet type is being actively phased out and discouraged from being used due to the backup hassle.",
 "order": 1,
 "isReference": false,
 "deprecated": false,
 "hidden": false,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "reusableContent": [],
 "previousSlug": "",
 "slugUpdatedAt": "2022-09-20T18:32:50.808Z",
 "revision": 3,
 "_id": "63f5176df91c7700118e780c",
 "version": "63f5176df91c7700118e7825",
 "updatedAt": "2023-01-12T20:44:34.387Z",
 "createdAt": "2019-10-28T20:04:09.555Z",
 "project": "5daf2e65f4109c0040fd51e1",
 "user": "62b2101422da70001ee51d95",
 "parentDoc": "63f5176df91c7700118e780a",
 "category": "63f5176df91c7700118e779e",
 "__v": 1,
 "pendingAlgoliaPublish": false,
 "isApi": false,
 "id": "63f5176df91c7700118e780c",
 "body_html": "<p>Dash wallets at their core are a collection of <span class=\"GlossaryItem-trigger\">private keys</span>. These collections are stored digitally in a file, or can even be physically stored on pieces of paper.</p>\n<h1 class=\"heading heading-1 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"private-key-formats\"></div><div class=\"heading-text\"><div id=\"section-private-key-formats\" class=\"heading-anchor_backwardsCompatibility\"></div>Private Key Formats</div><a aria-label=\"Skip link to Private Key Formats\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#private-key-formats\"></a></h1>\n<p>Private keys are what are used to unlock <span class=\"GlossaryItem-trigger\">duffs</span> from a particular <span class=\"GlossaryItem-trigger\">address</span>. In Dash, a private key in standard format is simply a 256-bit number, between the values:</p>\n<p><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">0x01</code> and <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140</code>, representing nearly the entire range of 2<sup>256</sup>-1 values. The range is governed by the secp256k1 ECDSA encryption standard used by Dash.</p>\n<h2 class=\"heading heading-2 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"wallet-import-format-wif\"></div><div class=\"heading-text\"><div id=\"section-wallet-import-format-wif\" class=\"heading-anchor_backwardsCompatibility\"></div>Wallet Import Format (WIF)</div><a aria-label=\"Skip link to Wallet Import Format (WIF)\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#wallet-import-format-wif\"></a></h2>\n<p>In order to make copying of private keys less prone to error, <span class=\"GlossaryItem-trigger\">Wallet Import Format</span> may be utilized. WIF uses <span class=\"GlossaryItem-trigger\">base58check</span> encoding on a private key, greatly decreasing the chance of copying error, much like standard Dash <span class=\"GlossaryItem-trigger\">addresses</span>.</p>\n<ol>\n<li>\n<p>Take a private key.</p>\n</li>\n<li>\n<p>Add a <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">0xCC</code> byte in front of it for <span class=\"GlossaryItem-trigger\">mainnet</span> addresses or <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">0xEF</code> for <span class=\"GlossaryItem-trigger\">testnet</span> addresses.</p>\n</li>\n<li>\n<p>Append a <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">0x01</code> byte after it if it should be used with compressed public keys (described in a later subsection). Nothing is appended if it is used with uncompressed public keys.</p>\n</li>\n<li>\n<p>Perform a SHA-256 hash on the <span class=\"GlossaryItem-trigger\">extended key</span>.</p>\n</li>\n<li>\n<p>Perform a SHA-256 hash on result of SHA-256 hash.</p>\n</li>\n<li>\n<p>Take the first four bytes of the second SHA-256 hash; this is the checksum.</p>\n</li>\n<li>\n<p>Add the four checksum bytes from point 5 at the end of the extended key from point 2.</p>\n</li>\n<li>\n<p>Convert the result from a byte string into a Base58 string using Base58Check encoding.</p>\n</li>\n</ol>\n<p>The process is easily reversible, using the Base58 decoding function, and removing the padding.</p>\n<h2 class=\"heading heading-2 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"mini-private-key-format\"></div><div class=\"heading-text\"><div id=\"section-mini-private-key-format\" class=\"heading-anchor_backwardsCompatibility\"></div>Mini Private Key Format</div><a aria-label=\"Skip link to Mini Private Key Format\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#mini-private-key-format\"></a></h2>\n<p>Mini private key format is a method for encoding a private key in under 30 characters, enabling keys to be embedded in a small physical space and more damage-resistant QR codes.</p>\n<ol>\n<li>\n<p>The first character of mini keys is &#x27;<button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">S</code>&#x27;.</p>\n</li>\n<li>\n<p>In order to determine if a mini private key is well-formatted, a question mark is added to the private key.</p>\n</li>\n<li>\n<p>The SHA256 hash is calculated. If the first byte produced is a <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">00</code>, it is well-formatted. This key restriction acts as a typo-checking mechanism. A user brute forces the process using random numbers until a well-formatted mini private key is produced.</p>\n</li>\n<li>\n<p>In order to derive the full private key, the user simply takes a single SHA256 hash of the original mini private key. This process is one-way: it is intractable to compute the mini private key format from the derived key.</p>\n</li>\n</ol>\n<p>Many implementations disallow the character &#x27;1&#x27; in the mini private key due to its visual similarity to &#x27;l&#x27;.</p>\n<p><strong>Resource:</strong> A common tool to create and redeem these keys is the <a href=\"https://github.com/casascius/Bitcoin-Address-Utility\" target=\"\" title=\"\">Casascius Bitcoin Address Utility</a>. Note: this tool is no longer actively developed.</p>\n<h1 class=\"heading heading-1 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"public-key-formats\"></div><div class=\"heading-text\"><div id=\"section-public-key-formats\" class=\"heading-anchor_backwardsCompatibility\"></div>Public Key Formats</div><a aria-label=\"Skip link to Public Key Formats\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#public-key-formats\"></a></h1>\n<p>Dash ECDSA public keys represent a point on a particular Elliptic Curve (EC) defined in secp256k1. In their traditional uncompressed form, public keys contain an identification byte, a 32-byte X coordinate, and a 32-byte Y coordinate. The extremely simplified illustration below shows such a point on the elliptic curve used by Dash, y<sup>2</sup>\u00a0=\u00a0x<sup>3</sup>\u00a0+\u00a07, over a field of contiguous numbers.</p>\n<p><span aria-label=\"Point On ECDSA Curve\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Point On ECDSA Curve\" loading=\"lazy\" src=\"https://dash-docs.github.io/img/dev/en-ecdsa-compressed-public-key.svg\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>(Secp256k1 actually modulos coordinates by a large prime, which produces a field of non-contiguous integers and a significantly less clear plot, although the principles are the same.)</p>\n<p>An almost 50% reduction in <span class=\"GlossaryItem-trigger\">public key</span> size can be realized without changing any fundamentals by dropping the Y coordinate. This is possible because only two points along the curve share any particular X coordinate, so the 32-byte Y coordinate can be replaced with a single bit indicating whether the point is on what appears in the illustration as the &quot;top&quot; side or the &quot;bottom&quot; side.</p>\n<p>No data is lost by creating a <span class=\"GlossaryItem-trigger\">compressed public key</span>---only a small amount of CPU is necessary to reconstruct the Y coordinate and access the uncompressed public key. Both uncompressed and compressed public keys are described in official secp256k1 documentation and supported by default in the widely-used OpenSSL library.</p>\n<p>Because they&#x27;re easy to use, and because they reduce almost by half the <span class=\"GlossaryItem-trigger\">block chain</span> space used to store public keys for every spent <span class=\"GlossaryItem-trigger\">output</span>, compressed public keys are the default in Dash Core and are the recommended default for all Dash software.</p>\n<p>However, Bitcoin Core prior to 0.6 used uncompressed keys.  This creates a few complications, as the hashed form of an uncompressed key is different than the hashed form of a compressed key, so the same key works with two different <span class=\"GlossaryItem-trigger\">P2PKH</span> addresses.   This also means that the key must be submitted in the correct format in the <span class=\"GlossaryItem-trigger\">signature script</span> so it matches the hash in the previous output&#x27;s pubkey script.</p>\n<p>For this reason, Bitcoin Core (and Dash Core) uses several different identifier bytes to help programs identify how keys should be used:</p>\n<ul>\n<li>\n<p>Private keys meant to be used with compressed public keys have 0x01 appended to them before being Base-58 encoded. (See the private key encoding section above.)</p>\n</li>\n<li>\n<p>Uncompressed public keys start with 0x04; compressed public keys begin with 0x03 or 0x02 depending on whether they&#x27;re greater or less than the midpoint of the curve.  These prefix bytes are all used in official secp256k1 documentation.</p>\n</li>\n</ul>\n<h1 class=\"heading heading-1 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"hierarchical-deterministic-key-creation\"></div><div class=\"heading-text\"><div id=\"section-hierarchical-deterministic-key-creation\" class=\"heading-anchor_backwardsCompatibility\"></div>Hierarchical Deterministic Key Creation</div><a aria-label=\"Skip link to Hierarchical Deterministic Key Creation\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#hierarchical-deterministic-key-creation\"></a></h1>\n<p>The hierarchical deterministic key creation and transfer protocol (<span class=\"GlossaryItem-trigger\">HD protocol</span>) greatly simplifies wallet backups, eliminates the need for repeated communication between multiple programs using the same wallet, permits creation of child accounts which can operate independently, gives each parent account the ability to monitor or control its children even if the child account is compromised, and divides each account into full-access and restricted-access parts so untrusted users or programs can be allowed to receive or monitor payments without being able to spend them.</p>\n<p>The HD protocol takes advantage of the ECDSA public key creation function, <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">&lt;&lt;glossary:point&gt;&gt;()</code>, which takes a large integer (the private key) and turns it into a graph point (the public key):</p>\n<pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">point(private_key) == public_key\n</code></pre>\n<p>Because of the way <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">point()</code> works, it&#x27;s possible to create a <span class=\"GlossaryItem-trigger\">child public key</span> by combining an existing <span class=\"GlossaryItem-trigger\">parent public key</span> with another public key created from any integer (<em>i</em>) value. This child public key is the same public key which would be created by the <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">point()</code> function if you added the <em>i</em> value to the original (parent) private key and then found the remainder of that sum divided by a global constant used by all Dash software (<em>p</em>):</p>\n<pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">point( (parent_private_key + i) % p ) == parent_public_key + point(i)\n</code></pre>\n<p>This means that two or more independent programs which agree on a sequence of integers can create a series of unique <span class=\"GlossaryItem-trigger\">child key</span> pairs from a single <span class=\"GlossaryItem-trigger\">parent key</span> pair without any further communication. Moreover, the program which distributes new public keys for receiving payment can do so without any access to the private keys, allowing the public key distribution program to run on a possibly-insecure platform such as a public web server.</p>\n<p>Child public keys can also create their own child public keys (grandchild public keys) by repeating the child key derivation operations:</p>\n<pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">point( (child_private_key + i) % p ) == child_public_key + point(i)\n</code></pre>\n<p>Whether creating child public keys or further-descended public keys, a predictable sequence of integer values would be no better than using a single public key for all transactions, as anyone who knew one child public key could find all of the other child public keys created from the same parent public key. Instead, a random seed can be used to deterministically generate the sequence of integer values so that the relationship between the child public keys is invisible to anyone without that seed.</p>\n<p>The HD protocol uses a single <span class=\"GlossaryItem-trigger\">root seed</span> to create a hierarchy of child, grandchild, and other descended keys with unlinkable deterministically-generated integer values. Each child key also gets a deterministically-generated seed from its parent, called a <span class=\"GlossaryItem-trigger\">chain code</span>, so the compromising of one chain code doesn&#x27;t necessarily compromise the integer sequence for the whole hierarchy, allowing the <span class=\"GlossaryItem-trigger\">master chain code</span> to continue being useful even if, for example, a web-based public key distribution program gets hacked.</p>\n<p><span aria-label=\"Overview Of Hierarchical Deterministic Key Derivation\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Overview Of Hierarchical Deterministic Key Derivation\" loading=\"lazy\" src=\"https://dash-docs.github.io/img/dev/en-hd-overview.svg\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>As illustrated above, HD key derivation takes four inputs:</p>\n<ul>\n<li>\n<p>The <em><span class=\"GlossaryItem-trigger\">parent private key</span></em> and <em><span class=\"GlossaryItem-trigger\">parent public key</span></em> are regular uncompressed 256-bit ECDSA keys.</p>\n</li>\n<li>\n<p>The <span class=\"GlossaryItem-trigger\">parent chain code</span> is 256 bits of seemingly-random data.</p>\n</li>\n<li>\n<p>The <span class=\"GlossaryItem-trigger\">index</span> number is a 32-bit integer specified by the program.</p>\n</li>\n</ul>\n<p>In the normal form shown in the above illustration, the <span class=\"GlossaryItem-trigger\">parent chain code</span>, the parent public key, and the index number are fed into a one-way cryptographic hash (<a href=\"https://en.wikipedia.org/wiki/HMAC\" target=\"\" title=\"\">HMAC-SHA512</a>) to produce 512 bits of deterministically-generated-but-seemingly-random data. The seemingly-random 256 bits on the right-hand side of the hash output are used as a new child chain code. The seemingly-random 256 bits on the left-hand side of the hash output are used as the integer value to be combined with either the parent private key or parent public key to, respectively, create either a child private key or child public key:</p>\n<pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">child_private_key == (parent_private_key + lefthand_hash_output) % G \nchild_public_key == point( (parent_private_key + lefthand_hash_output) % G ) \nchild_public_key == point(child_private_key) == parent_public_key + point(lefthand_hash_output)\n</code></pre>\n<p>Specifying different index numbers will create different unlinkable child keys from the same parent keys.  Repeating the procedure for the child keys using the child chain code will create unlinkable grandchild keys.</p>\n<p>Because creating child keys requires both a key and a chain code, the key and chain code together are called the <span class=\"GlossaryItem-trigger\">extended key</span>. An <span class=\"GlossaryItem-trigger\">extended private key</span> and its corresponding <span class=\"GlossaryItem-trigger\">extended public key</span> have the same chain code. The (top-level parent) <span class=\"GlossaryItem-trigger\">master private key</span> and master chain code are derived from random data, as illustrated below.</p>\n<p><span aria-label=\"Creating A Root Extended Key Pair\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Creating A Root Extended Key Pair\" loading=\"lazy\" src=\"https://dash-docs.github.io/img/dev/en-hd-root-keys.svg\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>A <span class=\"GlossaryItem-trigger\">root seed</span> is created from either 128 bits, 256 bits, or 512 bits of random data. This root seed of as little as 128 bits is the the only data the user needs to backup in order to derive every key created by a particular wallet program using particular settings.</p>\n<blockquote class=\"callout callout_warn\" theme=\"\ud83d\udea7\"><h2 class=\"callout-heading\"><span class=\"callout-icon\">\ud83d\udea7</span><p>HD Wallet Compatibility</p></h2><p><strong>Warning:</strong> HD wallet programs are not always fully compatible, so users must only use the same HD wallet program with the same HD-related settings for a particular root seed.</p></blockquote>\n<p>The root seed is hashed to create 512 bits of seemingly-random data, from which the master private key and master chain code are created (together, the master extended private key). The master public key is derived from the master private key using <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">point()</code>, which, together with the master chain code, is the master extended public key. The master extended keys are functionally equivalent to other extended keys; it is only their location at the top of the hierarchy which makes them special.</p>\n<h2 class=\"heading heading-2 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"hardened-keys\"></div><div class=\"heading-text\"><div id=\"section-hardened-keys\" class=\"heading-anchor_backwardsCompatibility\"></div>Hardened Keys</div><a aria-label=\"Skip link to Hardened Keys\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#hardened-keys\"></a></h2>\n<p>Hardened extended keys fix a potential problem with normal extended keys. If an attacker gets a normal parent chain code and parent public key, he can brute-force all chain codes deriving from it. If the attacker also obtains a child, grandchild, or further-descended private key, he can use the chain code to generate all of the extended private keys descending from that private key, as shown in the grandchild and great-grandchild generations of the illustration below.</p>\n<p><span aria-label=\"Cross-Generational Key Compromise\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Cross-Generational Key Compromise\" loading=\"lazy\" src=\"https://dash-docs.github.io/img/dev/en-hd-cross-generational-key-compromise.svg\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>Perhaps worse, the attacker can reverse the normal <span class=\"GlossaryItem-trigger\">child private key</span> derivation formula and subtract a <span class=\"GlossaryItem-trigger\">parent chain code</span> from a child private key to recover the <span class=\"GlossaryItem-trigger\">parent private key</span>, as shown in the child and parent generations of the illustration above.  This means an attacker who acquires an <span class=\"GlossaryItem-trigger\">extended public key</span> and any private key descended from it can recover that public key&#x27;s private key and all keys descended from it.</p>\n<p>For this reason, the <span class=\"GlossaryItem-trigger\">chain code</span> part of an extended public key should be better secured than standard public keys and users should be advised against exporting even non-extended private keys to possibly-untrustworthy environments.</p>\n<p>This can be fixed, with some tradeoffs, by replacing the the normal key derivation formula with a hardened key derivation formula.</p>\n<p>The normal key derivation formula, described in the section above, combines together the index number, the parent chain code, and the parent public key to create the child chain code and the integer value which is combined with the parent private key to create the child private key.</p>\n<p><span aria-label=\"Creating Child Public Keys From An Extended Private Key\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Creating Child Public Keys From An Extended Private Key\" loading=\"lazy\" src=\"https://dash-docs.github.io/img/dev/en-hd-private-parent-to-private-child.svg\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>The hardened formula, illustrated above, combines together the index number, the parent chain code, and the parent private key to create the data used to generate the child chain code and child private key. This formula makes it impossible to create child public keys without knowing the parent private key. In other words, parent extended public keys can&#x27;t create hardened child public keys.</p>\n<p>Because of that, a <span class=\"GlossaryItem-trigger\">hardened extended private key</span> is much less useful than a normal extended private key---however, hardened extended private keys create a firewall through which multi-level key derivation compromises cannot happen. Because hardened child extended public keys cannot generate grandchild chain codes on their own, the compromise of a parent extended public key cannot be combined with the compromise of a grandchild private key to create great-grandchild extended private keys.</p>\n<p>The HD protocol uses different index numbers to indicate whether a normal or hardened key should be generated. Index numbers from <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">0x00</code> to <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">0x7fffffff</code> (0 to 2<sup>31</sup>-1) will generate a normal key; index numbers from <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">0x80000000</code> to <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">0xffffffff</code> will generate a hardened key. To make descriptions easy, many developers use the <a href=\"https://en.wikipedia.org/wiki/Prime_%28symbol%29\" target=\"\" title=\"\">prime symbol</a> to indicate hardened keys, so the first normal key (0x00) is 0 and the first hardened key (0x80000000) is 0\u00b4.</p>\n<blockquote class=\"callout callout_info\" theme=\"\ud83d\udcd8\"><h2 class=\"callout-heading empty\"><span class=\"callout-icon\">\ud83d\udcd8</span></h2><p>Dash developers typically use the ASCII apostrophe rather than the unicode prime symbol, a convention we will henceforth follow.</p></blockquote>\n<p>This compact description is further combined with slashes prefixed by <em>m</em> or <em>M</em> to indicate hierarchy and key type, with <em>m</em> being a private key and <em>M</em> being a public key. For example, m/0&#x27;/0/122&#x27; refers to the 123rd hardened private child (by index number) of the first normal child (by index) of the first hardened child (by index) of the master private key. The following hierarchy illustrates prime notation and hardened key firewalls.</p>\n<p><span aria-label=\"Example HD Wallet Tree Using Prime Notation\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Example HD Wallet Tree Using Prime Notation\" loading=\"lazy\" src=\"https://dash-docs.github.io/img/dev/en-hd-tree.svg\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>Wallets following the <span class=\"GlossaryItem-trigger\">BIP32</span> <span class=\"GlossaryItem-trigger\">HD protocol</span> only create hardened children of the master private key (<em>m</em>) to prevent a compromised child key from compromising the master key. As there are no normal children for the master keys, the master public key is not used in HD wallets. All other keys can have normal children, so the corresponding extended public keys may be used instead.</p>\n<p>The HD protocol also describes a serialization format for extended public keys and extended private keys.  For details, please see the <a href=\"core-ref-wallets\" target=\"\" title=\"\">wallet section in the developer reference</a> or <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\" target=\"\" title=\"\">BIP32</a> for the full HD protocol specification.</p>\n<h2 class=\"heading heading-2 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"storing-root-seeds\"></div><div class=\"heading-text\"><div id=\"section-storing-root-seeds\" class=\"heading-anchor_backwardsCompatibility\"></div>Storing Root Seeds</div><a aria-label=\"Skip link to Storing Root Seeds\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#storing-root-seeds\"></a></h2>\n<p>Root seeds in the HD protocol are 128, 256, or 512 bits of random data which must be backed up precisely. To make it more convenient to use non-digital backup methods, such as memorization or hand-copying, <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\" target=\"\" title=\"\">BIP39</a> defines a method for creating a 512-bit root seed from a pseudo-sentence (mnemonic) of common natural-language words which was itself created from 128 to 256 bits of entropy and optionally protected by a password.</p>\n<p>The number of words generated correlates to the amount of entropy used:</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<div class=\"rdmd-table\"><div class=\"rdmd-table-inner\"><table><thead><tr><th>Entropy Bits</th><th>Words</th></tr></thead><tbody><tr><td>128</td><td>12</td></tr><tr><td>160</td><td>15</td></tr><tr><td>192</td><td>18</td></tr><tr><td>224</td><td>21</td></tr><tr><td>256</td><td>24</td></tr></tbody></table></div></div>\n<p>The passphrase can be of any length.  It is simply appended to the mnemonic pseudo-sentence, and then both the mnemonic and password are hashed 2,048 times using HMAC-SHA512, resulting in a seemingly-random 512-bit seed.  Because any input to the hash function creates a seemingly-random 512-bit seed, there is no fundamental way to prove the user entered the correct password, possibly allowing the user to protect a seed even when under duress.</p>\n<p>For implementation details, please see <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\" target=\"\" title=\"\">BIP39</a>.</p>\n<h1 class=\"heading heading-1 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"loose-key-wallets\"></div><div class=\"heading-text\"><div id=\"section-loose-key-wallets\" class=\"heading-anchor_backwardsCompatibility\"></div>Loose-Key Wallets</div><a aria-label=\"Skip link to Loose-Key Wallets\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#loose-key-wallets\"></a></h1>\n<p>Loose-Key wallets, also called &quot;Just a Bunch Of Keys (JBOK)&quot;, are a form of wallet that originated from the Bitcoin Core client wallet. The Dash Core client wallet creates 1000 private key/public key pairs automatically via a Pseudo-Random-Number Generator (PRNG) for later use.</p>\n<p>These unused private keys are stored in a virtual &quot;key pool&quot;, with new keys being generated whenever a previously-generated key was used, ensuring the pool maintained 1000 unused keys. (If the wallet is encrypted, new keys are only generated while the wallet is unlocked.)</p>\n<p>This creates considerable difficulty in backing up one\u2019s keys, considering backups have to be run manually to save the newly-generated private keys. If a new key pair set is generated, used, and then lost prior to a backup, the stored duffs are likely lost forever. Many older-style mobile wallets followed a similar format, but only generated a new private key upon user demand.</p>\n<p>This wallet type is being actively phased out and discouraged from being used due to the backup hassle.</p>"
}