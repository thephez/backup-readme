{
 "metadata": {
  "image": [],
  "title": "Wallet Programs",
  "description": "Permitting receiving and spending of duffs is the only essential feature of wallet software---but a particular wallet program doesn't need to do both things.",
  "keywords": "",
  "robots": "index"
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "status": 200,
     "language": "json",
     "code": "{}",
     "name": ""
    },
    {
     "status": 400,
     "language": "json",
     "code": "{}",
     "name": ""
    }
   ]
  },
  "params": []
 },
 "next": {
  "description": "",
  "pages": [
   {
    "type": "doc",
    "icon": "file-text-o",
    "name": "Wallet Files",
    "slug": "core-guide-wallets-wallet-files",
    "category": "Core Guides"
   }
  ]
 },
 "algolia": {
  "recordCount": 6,
  "publishPending": false,
  "translationFailure": false,
  "updatedAt": "2023-02-21T19:16:05.729Z"
 },
 "title": "Wallet Programs",
 "icon": "",
 "updates": [],
 "type": "basic",
 "slug": "core-guide-wallets-wallet-programs",
 "excerpt": "",
 "body": "Permitting receiving and spending of <<glossary:duffs>> is the only essential feature of <<glossary:wallet>> software---but a particular wallet program doesn't need to do both things.  Two wallet programs can work together, one program distributing <<glossary:public keys>> in order to receive duffs and another program signing <<glossary:transactions>> spending those duffs.\n\nWallet programs also need to interact with the peer-to-peer <<glossary:network>> to get information from the <<glossary:block chain>> and to broadcast new transactions. However, the programs which distribute public keys or sign transactions don't need to interact with the peer-to-peer network themselves.\n\nThis leaves us with three necessary, but separable, parts of a wallet system: a public key distribution program, a signing program, and a networked program.  In the subsections below, we will describe common combinations of these parts.\n\n> \ud83d\udcd8\n>\n> Note: we speak about distributing public keys generically. In many cases, P2PKH or P2SH hashes will be distributed instead of public keys, with the actual public keys only being distributed when the outputs they control are spent.\n\n# Full-Service Wallets\n\nThe simplest wallet is a program which performs all three functions: it generates <<glossary:private keys>>, derives the corresponding <<glossary:public keys>>, helps distribute those public keys as necessary, monitors for outputs spent to those public keys, creates and signs transactions spending those outputs, and broadcasts the signed transactions.\n\n![Full-Service Wallets](https://dash-docs.github.io/img/dev/en-wallets-full-service.svg)\n\nAs of this writing, almost all popular wallets can be used as full-service wallets.\n\nThe main advantage of full-service wallets is that they are easy to use. A single program does everything the user needs to receive and spend duffs.\n\nThe main disadvantage of full-service wallets is that they store the private keys on a device connected to the Internet.  The compromise of such devices is a common occurrence, and an Internet connection makes it easy to transmit private keys from a compromised device to an attacker.\n\nTo help protect against theft, many wallet programs offer users the option of encrypting the wallet files which contain the private keys. This protects the private keys when they aren't being used, but it cannot protect against an attack designed to capture the encryption key or to read the decrypted keys from memory.\n\n# Signing-Only Wallets\n\nTo increase security, private keys can be generated and stored by a separate wallet program operating in a more secure environment. These signing-only wallets work in conjunction with a networked wallet which interacts with the peer-to-peer network.\n\nSigning-only wallets programs typically use deterministic key creation (described in a [later subsection](core-guide-wallets-wallet-files#hierarchical-deterministic-key-creation)) to create parent private and public keys which can create child private and public keys.\n\n![Signing-Only Wallets](https://dash-docs.github.io/img/dev/en-wallets-signing-only.svg)\n\nWhen first run, the signing-only wallet creates a <<glossary:parent private key>> and transfers the corresponding <<glossary:parent public key>> to the networked wallet.\n\nThe networked wallet uses the parent public key to derive each <<glossary:child public key>>, optionally helps distribute them, monitors for outputs spent to those public keys, creates unsigned transactions spending those outputs, and transfers the unsigned transactions to the signing-only wallet.\n\nOften, users are given a chance to review the unsigned transactions' details (particularly the output details) using the signing-only wallet.\n\nAfter the optional review step, the signing-only wallet uses the parent private key to derive each appropriate <<glossary:child private key>> and signs the transactions, giving the signed transactions back to the networked wallet.\n\nThe networked wallet then broadcasts the signed transactions to the peer-to-peer <<glossary:network>>.\n\nThe following subsections describe the two most common variants of signing-only wallets: offline wallets and hardware wallets.\n\n## Offline Wallets\n\nSeveral full-service wallets programs will also operate as two separate wallets: one program instance acting as a signing-only wallet (often called an \"offline wallet\") and the other program instance acting as the networked wallet (often called an \"online wallet\" or \"watching-only wallet\").\n\nThe offline wallet is so named because it is intended to be run on a device which does not connect to any network, greatly reducing the number of attack vectors. If this is the case, it is usually up to the user to handle all data transfer using removable media such as USB drives.  The user's workflow is something like:\n\n1. (Offline) Disable all network connections on a device and install the wallet software. Start the wallet software in offline mode to create the parent private and public keys.  Copy the parent public key to removable media.\n\n2. (Online) Install the wallet software on another device, this one connected to the Internet, and import the parent public key from the removable media. As you would with a full-service wallet, distribute public keys to receive payment. When ready to spend duffs, fill in the output details and save the unsigned transaction generated by the wallet to removable media.\n\n3. (Offline) Open the unsigned transaction in the offline instance, review the output details to make sure they spend the correct amount to the correct address. This prevents malware on the online wallet from tricking the user into signing a transaction which pays an attacker. After review, sign the transaction and save it to removable media.\n\n4. (Online) Open the signed transaction in the online instance so it can broadcast it to the peer-to-peer network.\n\nThe primary advantage of offline wallets is their possibility for greatly improved security over full-service wallets.  As long as the offline wallet is not compromised (or flawed) and the user reviews all outgoing transactions before signing, the user's duffs are safe even if the online wallet is compromised.\n\nThe primary disadvantage of offline wallets is hassle. For maximum security, they require the user dedicate a device to only offline tasks. The offline device must be booted up whenever funds are to be spent, and the user must physically copy data from the online device to the offline device and back.\n\n## Hardware Wallets\n\nHardware wallets are devices dedicated to running a signing-only wallet. Their dedication lets them eliminate many of the vulnerabilities present in operating systems designed for general use, allowing them to safely communicate directly with other devices so users don't need to transfer data manually.  The user's workflow is something like:\n\n1. (Hardware) Create parent private and public keys. Connect hardware wallet to a networked device so it can get the parent public key.\n\n2. (Networked) As you would with a full-service wallet, distribute public keys to receive payment. When ready to spend duffs, fill in the transaction details, connect the hardware wallet, and click Spend.  The networked wallet will automatically send the transaction details to the hardware wallet.\n\n3. (Hardware) Review the transaction details on the hardware wallet's screen. Some hardware wallets may prompt for a passphrase or PIN number. The hardware wallet signs the transaction and uploads it to the networked wallet.\n\n4. (Networked) The networked wallet receives the signed transaction from the hardware wallet and broadcasts it to the network.\n\nThe primary advantage of hardware wallets is their possibility for greatly improved security over full-service wallets with much less hassle than offline wallets.\n\nThe primary disadvantage of hardware wallets is their hassle. Even though the hassle is less than that of offline wallets, the user must still purchase a hardware wallet device and carry it with them whenever they need to make a transaction using the signing-only wallet. An additional disadvantage is that not all wallet programs support hardware wallets.\n\n# Distributing-Only Wallets\n\nWallet programs which run in difficult-to-secure environments, such as webservers, can be designed to distribute public keys (including P2PKH or P2SH addresses) and nothing more.  There are two common ways to design these minimalist wallets:\n\n![Distributing-Only Wallets](https://dash-docs.github.io/img/dev/en-wallets-distributing-only.svg)\n\n* Pre-populate a database with a number of public keys or addresses, and then distribute on request a pubkey script or address using one of the database entries. To [avoid key reuse](core-guide-transactions-avoiding-key-reuse), webservers should keep track of used keys and never run out of public keys. This can be made easier by using parent public keys as suggested in the next method.\n\n* Use a parent public key to create child public keys. To avoid key reuse, a method must be used to ensure the same public key isn't distributed twice. This can be a database entry for each key distributed or an incrementing pointer to the key index number.\n\nNeither method adds a significant amount of overhead, especially if a database is used anyway to associate each incoming payment with a separate public key for payment tracking.",
 "order": 0,
 "isReference": false,
 "deprecated": false,
 "hidden": false,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "reusableContent": [],
 "previousSlug": "",
 "slugUpdatedAt": "2022-09-20T18:32:50.202Z",
 "revision": 3,
 "_id": "63f5176df91c7700118e780b",
 "version": "63f5176df91c7700118e7825",
 "updatedAt": "2023-01-12T20:45:14.578Z",
 "createdAt": "2019-10-28T20:03:52.447Z",
 "project": "5daf2e65f4109c0040fd51e1",
 "user": "62b2101422da70001ee51d95",
 "parentDoc": "63f5176df91c7700118e780a",
 "category": "63f5176df91c7700118e779e",
 "__v": 1,
 "pendingAlgoliaPublish": false,
 "isApi": false,
 "id": "63f5176df91c7700118e780b",
 "body_html": "<p>Permitting receiving and spending of <span class=\"GlossaryItem-trigger\">duffs</span> is the only essential feature of <span class=\"GlossaryItem-trigger\">wallet</span> software---but a particular wallet program doesn&#x27;t need to do both things.  Two wallet programs can work together, one program distributing <span class=\"GlossaryItem-trigger\">public keys</span> in order to receive duffs and another program signing <span class=\"GlossaryItem-trigger\">transactions</span> spending those duffs.</p>\n<p>Wallet programs also need to interact with the peer-to-peer <span class=\"GlossaryItem-trigger\">network</span> to get information from the <span class=\"GlossaryItem-trigger\">block chain</span> and to broadcast new transactions. However, the programs which distribute public keys or sign transactions don&#x27;t need to interact with the peer-to-peer network themselves.</p>\n<p>This leaves us with three necessary, but separable, parts of a wallet system: a public key distribution program, a signing program, and a networked program.  In the subsections below, we will describe common combinations of these parts.</p>\n<blockquote class=\"callout callout_info\" theme=\"\ud83d\udcd8\"><h2 class=\"callout-heading empty\"><span class=\"callout-icon\">\ud83d\udcd8</span></h2><p>Note: we speak about distributing public keys generically. In many cases, P2PKH or P2SH hashes will be distributed instead of public keys, with the actual public keys only being distributed when the outputs they control are spent.</p></blockquote>\n<h1 class=\"heading heading-1 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"full-service-wallets\"></div><div class=\"heading-text\"><div id=\"section-full-service-wallets\" class=\"heading-anchor_backwardsCompatibility\"></div>Full-Service Wallets</div><a aria-label=\"Skip link to Full-Service Wallets\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#full-service-wallets\"></a></h1>\n<p>The simplest wallet is a program which performs all three functions: it generates <span class=\"GlossaryItem-trigger\">private keys</span>, derives the corresponding <span class=\"GlossaryItem-trigger\">public keys</span>, helps distribute those public keys as necessary, monitors for outputs spent to those public keys, creates and signs transactions spending those outputs, and broadcasts the signed transactions.</p>\n<p><span aria-label=\"Full-Service Wallets\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Full-Service Wallets\" loading=\"lazy\" src=\"https://dash-docs.github.io/img/dev/en-wallets-full-service.svg\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>As of this writing, almost all popular wallets can be used as full-service wallets.</p>\n<p>The main advantage of full-service wallets is that they are easy to use. A single program does everything the user needs to receive and spend duffs.</p>\n<p>The main disadvantage of full-service wallets is that they store the private keys on a device connected to the Internet.  The compromise of such devices is a common occurrence, and an Internet connection makes it easy to transmit private keys from a compromised device to an attacker.</p>\n<p>To help protect against theft, many wallet programs offer users the option of encrypting the wallet files which contain the private keys. This protects the private keys when they aren&#x27;t being used, but it cannot protect against an attack designed to capture the encryption key or to read the decrypted keys from memory.</p>\n<h1 class=\"heading heading-1 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"signing-only-wallets\"></div><div class=\"heading-text\"><div id=\"section-signing-only-wallets\" class=\"heading-anchor_backwardsCompatibility\"></div>Signing-Only Wallets</div><a aria-label=\"Skip link to Signing-Only Wallets\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#signing-only-wallets\"></a></h1>\n<p>To increase security, private keys can be generated and stored by a separate wallet program operating in a more secure environment. These signing-only wallets work in conjunction with a networked wallet which interacts with the peer-to-peer network.</p>\n<p>Signing-only wallets programs typically use deterministic key creation (described in a <a href=\"core-guide-wallets-wallet-files#hierarchical-deterministic-key-creation\" target=\"\" title=\"\">later subsection</a>) to create parent private and public keys which can create child private and public keys.</p>\n<p><span aria-label=\"Signing-Only Wallets\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Signing-Only Wallets\" loading=\"lazy\" src=\"https://dash-docs.github.io/img/dev/en-wallets-signing-only.svg\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>When first run, the signing-only wallet creates a <span class=\"GlossaryItem-trigger\">parent private key</span> and transfers the corresponding <span class=\"GlossaryItem-trigger\">parent public key</span> to the networked wallet.</p>\n<p>The networked wallet uses the parent public key to derive each <span class=\"GlossaryItem-trigger\">child public key</span>, optionally helps distribute them, monitors for outputs spent to those public keys, creates unsigned transactions spending those outputs, and transfers the unsigned transactions to the signing-only wallet.</p>\n<p>Often, users are given a chance to review the unsigned transactions&#x27; details (particularly the output details) using the signing-only wallet.</p>\n<p>After the optional review step, the signing-only wallet uses the parent private key to derive each appropriate <span class=\"GlossaryItem-trigger\">child private key</span> and signs the transactions, giving the signed transactions back to the networked wallet.</p>\n<p>The networked wallet then broadcasts the signed transactions to the peer-to-peer <span class=\"GlossaryItem-trigger\">network</span>.</p>\n<p>The following subsections describe the two most common variants of signing-only wallets: offline wallets and hardware wallets.</p>\n<h2 class=\"heading heading-2 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"offline-wallets\"></div><div class=\"heading-text\"><div id=\"section-offline-wallets\" class=\"heading-anchor_backwardsCompatibility\"></div>Offline Wallets</div><a aria-label=\"Skip link to Offline Wallets\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#offline-wallets\"></a></h2>\n<p>Several full-service wallets programs will also operate as two separate wallets: one program instance acting as a signing-only wallet (often called an &quot;offline wallet&quot;) and the other program instance acting as the networked wallet (often called an &quot;online wallet&quot; or &quot;watching-only wallet&quot;).</p>\n<p>The offline wallet is so named because it is intended to be run on a device which does not connect to any network, greatly reducing the number of attack vectors. If this is the case, it is usually up to the user to handle all data transfer using removable media such as USB drives.  The user&#x27;s workflow is something like:</p>\n<ol>\n<li>\n<p>(Offline) Disable all network connections on a device and install the wallet software. Start the wallet software in offline mode to create the parent private and public keys.  Copy the parent public key to removable media.</p>\n</li>\n<li>\n<p>(Online) Install the wallet software on another device, this one connected to the Internet, and import the parent public key from the removable media. As you would with a full-service wallet, distribute public keys to receive payment. When ready to spend duffs, fill in the output details and save the unsigned transaction generated by the wallet to removable media.</p>\n</li>\n<li>\n<p>(Offline) Open the unsigned transaction in the offline instance, review the output details to make sure they spend the correct amount to the correct address. This prevents malware on the online wallet from tricking the user into signing a transaction which pays an attacker. After review, sign the transaction and save it to removable media.</p>\n</li>\n<li>\n<p>(Online) Open the signed transaction in the online instance so it can broadcast it to the peer-to-peer network.</p>\n</li>\n</ol>\n<p>The primary advantage of offline wallets is their possibility for greatly improved security over full-service wallets.  As long as the offline wallet is not compromised (or flawed) and the user reviews all outgoing transactions before signing, the user&#x27;s duffs are safe even if the online wallet is compromised.</p>\n<p>The primary disadvantage of offline wallets is hassle. For maximum security, they require the user dedicate a device to only offline tasks. The offline device must be booted up whenever funds are to be spent, and the user must physically copy data from the online device to the offline device and back.</p>\n<h2 class=\"heading heading-2 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"hardware-wallets\"></div><div class=\"heading-text\"><div id=\"section-hardware-wallets\" class=\"heading-anchor_backwardsCompatibility\"></div>Hardware Wallets</div><a aria-label=\"Skip link to Hardware Wallets\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#hardware-wallets\"></a></h2>\n<p>Hardware wallets are devices dedicated to running a signing-only wallet. Their dedication lets them eliminate many of the vulnerabilities present in operating systems designed for general use, allowing them to safely communicate directly with other devices so users don&#x27;t need to transfer data manually.  The user&#x27;s workflow is something like:</p>\n<ol>\n<li>\n<p>(Hardware) Create parent private and public keys. Connect hardware wallet to a networked device so it can get the parent public key.</p>\n</li>\n<li>\n<p>(Networked) As you would with a full-service wallet, distribute public keys to receive payment. When ready to spend duffs, fill in the transaction details, connect the hardware wallet, and click Spend.  The networked wallet will automatically send the transaction details to the hardware wallet.</p>\n</li>\n<li>\n<p>(Hardware) Review the transaction details on the hardware wallet&#x27;s screen. Some hardware wallets may prompt for a passphrase or PIN number. The hardware wallet signs the transaction and uploads it to the networked wallet.</p>\n</li>\n<li>\n<p>(Networked) The networked wallet receives the signed transaction from the hardware wallet and broadcasts it to the network.</p>\n</li>\n</ol>\n<p>The primary advantage of hardware wallets is their possibility for greatly improved security over full-service wallets with much less hassle than offline wallets.</p>\n<p>The primary disadvantage of hardware wallets is their hassle. Even though the hassle is less than that of offline wallets, the user must still purchase a hardware wallet device and carry it with them whenever they need to make a transaction using the signing-only wallet. An additional disadvantage is that not all wallet programs support hardware wallets.</p>\n<h1 class=\"heading heading-1 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"distributing-only-wallets\"></div><div class=\"heading-text\"><div id=\"section-distributing-only-wallets\" class=\"heading-anchor_backwardsCompatibility\"></div>Distributing-Only Wallets</div><a aria-label=\"Skip link to Distributing-Only Wallets\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#distributing-only-wallets\"></a></h1>\n<p>Wallet programs which run in difficult-to-secure environments, such as webservers, can be designed to distribute public keys (including P2PKH or P2SH addresses) and nothing more.  There are two common ways to design these minimalist wallets:</p>\n<p><span aria-label=\"Distributing-Only Wallets\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Distributing-Only Wallets\" loading=\"lazy\" src=\"https://dash-docs.github.io/img/dev/en-wallets-distributing-only.svg\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<ul>\n<li>\n<p>Pre-populate a database with a number of public keys or addresses, and then distribute on request a pubkey script or address using one of the database entries. To <a href=\"core-guide-transactions-avoiding-key-reuse\" target=\"\" title=\"\">avoid key reuse</a>, webservers should keep track of used keys and never run out of public keys. This can be made easier by using parent public keys as suggested in the next method.</p>\n</li>\n<li>\n<p>Use a parent public key to create child public keys. To avoid key reuse, a method must be used to ensure the same public key isn&#x27;t distributed twice. This can be a database entry for each key distributed or an incrementing pointer to the key index number.</p>\n</li>\n</ul>\n<p>Neither method adds a significant amount of overhead, especially if a database is used anyway to associate each incoming payment with a separate public key for payment tracking.</p>"
}