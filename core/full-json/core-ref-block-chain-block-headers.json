{
 "metadata": {
  "image": [],
  "title": "What are block headers?",
  "description": "Dash block headers are serialized in the 80-byte format hashed as part of the proof-of-work algorithm.",
  "keywords": "",
  "robots": "index"
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "status": 200,
     "language": "json",
     "code": "{}",
     "name": ""
    },
    {
     "status": 400,
     "language": "json",
     "code": "{}",
     "name": ""
    }
   ]
  },
  "params": []
 },
 "next": {
  "description": "",
  "pages": [
   {
    "type": "doc",
    "icon": "file-text-o",
    "name": "Serialized Blocks",
    "slug": "core-ref-block-chain-serialized-blocks",
    "category": "Core Reference"
   }
  ]
 },
 "algolia": {
  "recordCount": 4,
  "publishPending": false,
  "translationFailure": false,
  "updatedAt": "2023-02-21T19:15:42.786Z"
 },
 "title": "Block Headers",
 "icon": "",
 "updates": [],
 "type": "basic",
 "slug": "core-ref-block-chain-block-headers",
 "excerpt": "",
 "body": "<<glossary:Block headers>> are serialized in the 80-byte format described below and then hashed as part of the proof-of-work algorithm, making the serialized header format part of the <<glossary:consensus rules>>.\n\n| Bytes | Name                | Data Type | Description\n|-------|---------------------|-----------|----------------\n| 4     | version             |  int32_t  | The <<glossary:block>> version number indicates which set of block validation rules to follow. See the list of block versions below.\n| 32    | previous block header hash | char[32]  | An X11() hash in internal byte order of the previous block's header.  This ensures no previous block can be changed without also changing this block's header.\n| 32    | merkle root hash    | char[32]  | A SHA256(SHA256()) hash in internal byte order. The merkle root is derived from the hashes of all transactions included in this block, ensuring that none of those transactions can be modified without modifying the header.  See the [merkle trees section](#merkle-trees) below.\n| 4     | time                | uint32_t  | The block time is a Unix epoch time when the miner started hashing the header (according to the miner).  Must be strictly greater than the median time of the previous 11 blocks.  Full nodes will not accept blocks with headers more than two hours in the future according to their clock.\n| 4     | nBits               | uint32_t  | An encoded version of the target threshold this block's header hash must be less than or equal to.  See the nBits format described below.\n| 4     | nonce               | uint32_t  | An arbitrary number miners change to modify the header hash in order to produce a hash less than or equal to the target threshold.  If all 32-bit values are tested, the time can be updated or the coinbase transaction can be changed and the merkle root updated.\n\nThe hashes are in <<glossary:internal byte order>>; the other values are all in little-endian order.\n\nAn example <<glossary:header>> in hex:\n\n``` text\n02000000 ........................... Block version: 2\n\nb6ff0b1b1680a2862a30ca44d346d9e8\n910d334beb48ca0c0000000000000000 ... Hash of previous block's header\n9d10aa52ee949386ca9385695f04ede2\n70dda20810decd12bc9b048aaab31471 ... Merkle root\n\n24d95a54 ........................... Unix time: 1415239972\n30c31b18 ........................... Target: 0x1bc330 * 256**(0x18-3)\nfe9f0864 ........................... Nonce\n```\n\n# Block Versions\n\n* **Version 1** was used by Dash for the <<glossary:genesis block>> only.\n\n* **Version 2** was introduced with the first block following the <<glossary:genesis block>> (January 2014). As described in [BIP34](https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki), valid version 2 blocks require a <<glossary:block height>> parameter in the coinbase.\n\n* **Version 3** blocks were introduced in Dash Core 0.11.2 (March 2015) as a\n  soft fork (Block 244,834 was the first version 3 block).\n\n  When the <<glossary:fork>> reached full enforcement, it required strict [DER encoding](https://en.wikipedia.org/wiki/X.690#DER_encoding) of all <<glossary:ECDSA signatures>> in new blocks as described in [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki). Transactions that do not use strict DER encoding had previously been non-standard since Dash Core 0.8.0.\n\n* **Version 4** blocks specified in [BIP65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki) and introduced in Bitcoin Core 0.11.2 (November 2015) as a <<glossary:soft fork>> became active in December 2015.  These blocks now support the new `OP_CHECKLOCKTIMEVERIFY` <<glossary:opcode>> described in that BIP.\n\nThe mechanism used for the version 2, 3, and 4 upgrades is commonly called IsSuperMajority() after the function added to Dash Core to manage those soft forking changes. See [BIP34](https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki) for a full description of this method.\n\nAs of this writing, a newer method called *version bits* is being designed to manage future soft forking changes, although it's not known whether version 4 will be the last soft fork to use the IsSuperMajority() function. Draft [BIP9](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki) describes the version bits design as of this writing, although it is still being actively edited and may substantially change while in the draft state.\n\n# Merkle Trees\n\nThe <<glossary:merkle root>> is constructed using all the <<glossary:TXIDs>> of transactions in this block, but first the TXIDs are placed in order as required by the <<glossary:consensus rules>>:\n\n* The <<glossary:coinbase transaction>>'s <<glossary:TXID>> is always placed first.\n\n* Any <<glossary:input>> within this block can spend an <<glossary:output>> which also appears in this block (assuming the spend is otherwise valid). However, the TXID corresponding to the output must be placed at some point before the TXID corresponding to the input. This ensures that any program parsing block chain transactions linearly will encounter each output before it is used as an input.\n\nIf a <<glossary:block>> only has a coinbase transaction, the coinbase TXID is used as the merkle root hash.\n\nIf a block only has a coinbase transaction and one other transaction, the TXIDs of those two transactions are placed in order, concatenated as 64 raw bytes, and then SHA256(SHA256()) hashed together to form the merkle root.\n\nIf a block has three or more transactions, intermediate <<glossary:merkle tree>> rows are formed. The TXIDs are placed in order and paired, starting with the coinbase transaction's TXID. Each pair is concatenated together as 64 raw bytes and SHA256(SHA256()) hashed to form a second row of hashes. If there are an odd (non-even) number of TXIDs, the last TXID is concatenated with a copy of itself and hashed. If there are more than two hashes in the second row, the process is repeated to create a third row (and, if necessary, repeated further to create additional rows). Once a row is obtained with only two hashes, those hashes are concatenated and hashed to produce the merkle root.\n\n![Example Merkle Tree Construction](https://github.com/dash-docs/dash-docs/raw/master/img/dev/en-merkle-tree-construction.png)\n\nTXIDs and intermediate hashes are always in <<glossary:internal byte order>> when they're concatenated, and the resulting merkle root is also in internal byte order when it's placed in the <<glossary:block header>>.\n\n# Target nBits\n\nThe <<glossary:target threshold>> is a 256-bit unsigned integer which a <<glossary:header>> hash must be equal to or below in order for that header to be a valid part of the <<glossary:block chain>>. However, the header field *<<glossary:nBits>>* provides only 32 bits of space, so the <<glossary:target>> number uses a less precise format called \"compact\" which works like a base-256 version of scientific notation:\n\n![Converting nBits Into A Target Threshold](https://github.com/dash-docs/dash-docs/raw/master/img/dev/en-nbits-overview.png)\n\nAs a base-256 number, nBits can be quickly parsed as bytes the same way you might parse a decimal number in base-10 scientific notation:\n\n![Quickly Converting nBits](https://github.com/dash-docs/dash-docs/raw/master/img/dev/en-nbits-quick-parse.png)\n\nAlthough the target threshold should be an unsigned integer, the original nBits implementation inherits properties from a signed data class, allowing the target threshold to be negative if the high bit of the significand is set. This is useless---the header hash is treated as an unsigned number, so it can never be equal to or lower than a negative target threshold. Dash Core deals with this in two ways:\n\n* When parsing nBits, Dash Core converts a negative target threshold into a target of zero, which the header hash can equal (in theory, at least).\n\n* When creating a value for nBits, Dash Core checks to see if it will produce an nBits which will be interpreted as negative; if so, it divides the significand by 256 and increases the exponent by 1 to   produce the same number with a different encoding.\n\nSome examples taken from the Dash Core test cases:\n\n| nBits      |  Target          | Notes\n|------------|------------------|----------------\n| 0x01003456 | &nbsp;0x00       |\n| 0x01123456 | &nbsp;0x12       |\n| 0x02008000 | &nbsp;0x80       |\n| 0x05009234 | &nbsp;0x92340000 |\n| 0x04923456 | -0x12345600      | High bit set (0x80 in 0x92).\n| 0x04123456 | &nbsp;0x12345600 | Inverse of above; no high bit.\n\nDifficulty 1, the minimum allowed <<glossary:difficulty>>, is represented on <<glossary:mainnet>> and the current <<glossary:testnet>> by the nBits value 0x1e0ffff0. Regtest mode uses a different difficulty 1 value---0x207fffff, the highest possible value below uint32_max which can be encoded; this allows near-instant building of blocks in <<glossary:regression test mode>>.",
 "mdxAltBody": "",
 "order": 0,
 "isReference": false,
 "deprecated": false,
 "hidden": false,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "reusableContent": [],
 "previousSlug": "",
 "slugUpdatedAt": "2022-07-25T20:19:32.221Z",
 "revision": 1,
 "_id": "63f5176df91c7700118e77b2",
 "version": "63f5176df91c7700118e7825",
 "updatedAt": "2020-05-28T20:51:48.345Z",
 "createdAt": "2019-10-23T16:10:12.414Z",
 "project": "5daf2e65f4109c0040fd51e1",
 "user": "62b2101422da70001ee51d95",
 "parentDoc": "63f5176df91c7700118e77ad",
 "category": "63f5176df91c7700118e779d",
 "__v": 1,
 "pendingAlgoliaPublish": false,
 "isApi": false,
 "id": "63f5176df91c7700118e77b2",
 "body_html": "<p><span class=\"GlossaryItem-trigger\">Block headers</span> are serialized in the 80-byte format described below and then hashed as part of the proof-of-work algorithm, making the serialized header format part of the <span class=\"GlossaryItem-trigger\">consensus rules</span>.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<div class=\"rdmd-table\"><div class=\"rdmd-table-inner\"><table><thead><tr><th>Bytes</th><th>Name</th><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td>4</td><td>version</td><td>int32_t</td><td>The <span class=\"GlossaryItem-trigger\">block</span> version number indicates which set of block validation rules to follow. See the list of block versions below.</td></tr><tr><td>32</td><td>previous block header hash</td><td>char[32]</td><td>An X11() hash in internal byte order of the previous block&#x27;s header.  This ensures no previous block can be changed without also changing this block&#x27;s header.</td></tr><tr><td>32</td><td>merkle root hash</td><td>char[32]</td><td>A SHA256(SHA256()) hash in internal byte order. The merkle root is derived from the hashes of all transactions included in this block, ensuring that none of those transactions can be modified without modifying the header.  See the <a href=\"#merkle-trees\" target=\"\" title=\"\">merkle trees section</a> below.</td></tr><tr><td>4</td><td>time</td><td>uint32_t</td><td>The block time is a Unix epoch time when the miner started hashing the header (according to the miner).  Must be strictly greater than the median time of the previous 11 blocks.  Full nodes will not accept blocks with headers more than two hours in the future according to their clock.</td></tr><tr><td>4</td><td>nBits</td><td>uint32_t</td><td>An encoded version of the target threshold this block&#x27;s header hash must be less than or equal to.  See the nBits format described below.</td></tr><tr><td>4</td><td>nonce</td><td>uint32_t</td><td>An arbitrary number miners change to modify the header hash in order to produce a hash less than or equal to the target threshold.  If all 32-bit values are tested, the time can be updated or the coinbase transaction can be changed and the merkle root updated.</td></tr></tbody></table></div></div>\n<p>The hashes are in <span class=\"GlossaryItem-trigger\">internal byte order</span>; the other values are all in little-endian order.</p>\n<p>An example <span class=\"GlossaryItem-trigger\">header</span> in hex:</p>\n<div class=\"CodeTabs CodeTabs_initial theme-light\"><div class=\"CodeTabs-toolbar\" role=\"tablist\"><button aria-selected=\"true\" class=\"CodeTabs_active\" role=\"tab\" type=\"button\">Text</button></div><div class=\"CodeTabs-inner\" role=\"tabpanel\"><pre><button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang-text theme-light\" data-lang=\"text\" name=\"\" tabindex=\"0\">02000000 ........................... Block version: 2\n\nb6ff0b1b1680a2862a30ca44d346d9e8\n910d334beb48ca0c0000000000000000 ... Hash of previous block&#x27;s header\n9d10aa52ee949386ca9385695f04ede2\n70dda20810decd12bc9b048aaab31471 ... Merkle root\n\n24d95a54 ........................... Unix time: 1415239972\n30c31b18 ........................... Target: 0x1bc330 * 256**(0x18-3)\nfe9f0864 ........................... Nonce\n</code></pre></div></div>\n<h1 class=\"heading heading-1 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"block-versions\"></div><div class=\"heading-text\"><div id=\"section-block-versions\" class=\"heading-anchor_backwardsCompatibility\"></div>Block Versions</div><a aria-label=\"Skip link to Block Versions\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#block-versions\"></a></h1>\n<ul>\n<li>\n<p><strong>Version 1</strong> was used by Dash for the <span class=\"GlossaryItem-trigger\">genesis block</span> only.</p>\n</li>\n<li>\n<p><strong>Version 2</strong> was introduced with the first block following the <span class=\"GlossaryItem-trigger\">genesis block</span> (January 2014). As described in <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki\" target=\"\" title=\"\">BIP34</a>, valid version 2 blocks require a <span class=\"GlossaryItem-trigger\">block height</span> parameter in the coinbase.</p>\n</li>\n<li>\n<p><strong>Version 3</strong> blocks were introduced in Dash Core 0.11.2 (March 2015) as a<br/>\nsoft fork (Block 244,834 was the first version 3 block).</p>\n<p>When the <span class=\"GlossaryItem-trigger\">fork</span> reached full enforcement, it required strict <a href=\"https://en.wikipedia.org/wiki/X.690#DER_encoding\" target=\"\" title=\"\">DER encoding</a> of all <span class=\"GlossaryItem-trigger\">ECDSA signatures</span> in new blocks as described in <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\" target=\"\" title=\"\">BIP66</a>. Transactions that do not use strict DER encoding had previously been non-standard since Dash Core 0.8.0.</p>\n</li>\n<li>\n<p><strong>Version 4</strong> blocks specified in <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki\" target=\"\" title=\"\">BIP65</a> and introduced in Bitcoin Core 0.11.2 (November 2015) as a <span class=\"GlossaryItem-trigger\">soft fork</span> became active in December 2015.  These blocks now support the new <button aria-label=\"Copy Code\" class=\"rdmd-code-copy fa\"></button><code class=\"rdmd-code lang- theme-light\" data-lang=\"\" name=\"\" tabindex=\"0\">OP_CHECKLOCKTIMEVERIFY</code> <span class=\"GlossaryItem-trigger\">opcode</span> described in that BIP.</p>\n</li>\n</ul>\n<p>The mechanism used for the version 2, 3, and 4 upgrades is commonly called IsSuperMajority() after the function added to Dash Core to manage those soft forking changes. See <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki\" target=\"\" title=\"\">BIP34</a> for a full description of this method.</p>\n<p>As of this writing, a newer method called <em>version bits</em> is being designed to manage future soft forking changes, although it&#x27;s not known whether version 4 will be the last soft fork to use the IsSuperMajority() function. Draft <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki\" target=\"\" title=\"\">BIP9</a> describes the version bits design as of this writing, although it is still being actively edited and may substantially change while in the draft state.</p>\n<h1 class=\"heading heading-1 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"merkle-trees\"></div><div class=\"heading-text\"><div id=\"section-merkle-trees\" class=\"heading-anchor_backwardsCompatibility\"></div>Merkle Trees</div><a aria-label=\"Skip link to Merkle Trees\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#merkle-trees\"></a></h1>\n<p>The <span class=\"GlossaryItem-trigger\">merkle root</span> is constructed using all the <span class=\"GlossaryItem-trigger\">TXIDs</span> of transactions in this block, but first the TXIDs are placed in order as required by the <span class=\"GlossaryItem-trigger\">consensus rules</span>:</p>\n<ul>\n<li>\n<p>The <span class=\"GlossaryItem-trigger\">coinbase transaction</span>&#x27;s <span class=\"GlossaryItem-trigger\">TXID</span> is always placed first.</p>\n</li>\n<li>\n<p>Any <span class=\"GlossaryItem-trigger\">input</span> within this block can spend an <span class=\"GlossaryItem-trigger\">output</span> which also appears in this block (assuming the spend is otherwise valid). However, the TXID corresponding to the output must be placed at some point before the TXID corresponding to the input. This ensures that any program parsing block chain transactions linearly will encounter each output before it is used as an input.</p>\n</li>\n</ul>\n<p>If a <span class=\"GlossaryItem-trigger\">block</span> only has a coinbase transaction, the coinbase TXID is used as the merkle root hash.</p>\n<p>If a block only has a coinbase transaction and one other transaction, the TXIDs of those two transactions are placed in order, concatenated as 64 raw bytes, and then SHA256(SHA256()) hashed together to form the merkle root.</p>\n<p>If a block has three or more transactions, intermediate <span class=\"GlossaryItem-trigger\">merkle tree</span> rows are formed. The TXIDs are placed in order and paired, starting with the coinbase transaction&#x27;s TXID. Each pair is concatenated together as 64 raw bytes and SHA256(SHA256()) hashed to form a second row of hashes. If there are an odd (non-even) number of TXIDs, the last TXID is concatenated with a copy of itself and hashed. If there are more than two hashes in the second row, the process is repeated to create a third row (and, if necessary, repeated further to create additional rows). Once a row is obtained with only two hashes, those hashes are concatenated and hashed to produce the merkle root.</p>\n<p><span aria-label=\"Example Merkle Tree Construction\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Example Merkle Tree Construction\" loading=\"lazy\" src=\"https://github.com/dash-docs/dash-docs/raw/master/img/dev/en-merkle-tree-construction.png\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>TXIDs and intermediate hashes are always in <span class=\"GlossaryItem-trigger\">internal byte order</span> when they&#x27;re concatenated, and the resulting merkle root is also in internal byte order when it&#x27;s placed in the <span class=\"GlossaryItem-trigger\">block header</span>.</p>\n<h1 class=\"heading heading-1 header-scroll\" align=\"\"><div class=\"heading-anchor anchor waypoint\" id=\"target-nbits\"></div><div class=\"heading-text\"><div id=\"section-target-n-bits\" class=\"heading-anchor_backwardsCompatibility\"></div>Target nBits</div><a aria-label=\"Skip link to Target nBits\" class=\"heading-anchor-icon fa fa-anchor\" href=\"#target-nbits\"></a></h1>\n<p>The <span class=\"GlossaryItem-trigger\">target threshold</span> is a 256-bit unsigned integer which a <span class=\"GlossaryItem-trigger\">header</span> hash must be equal to or below in order for that header to be a valid part of the <span class=\"GlossaryItem-trigger\">block chain</span>. However, the header field <em><span class=\"GlossaryItem-trigger\">nBits</span></em> provides only 32 bits of space, so the <span class=\"GlossaryItem-trigger\">target</span> number uses a less precise format called &quot;compact&quot; which works like a base-256 version of scientific notation:</p>\n<p><span aria-label=\"Converting nBits Into A Target Threshold\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Converting nBits Into A Target Threshold\" loading=\"lazy\" src=\"https://github.com/dash-docs/dash-docs/raw/master/img/dev/en-nbits-overview.png\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>As a base-256 number, nBits can be quickly parsed as bytes the same way you might parse a decimal number in base-10 scientific notation:</p>\n<p><span aria-label=\"Quickly Converting nBits\" class=\"img lightbox closed\" role=\"button\" tabindex=\"0\"><span class=\"lightbox-inner\"><img alt=\"Quickly Converting nBits\" loading=\"lazy\" src=\"https://github.com/dash-docs/dash-docs/raw/master/img/dev/en-nbits-quick-parse.png\" align=\"\" caption=\"\" height=\"auto\" title=\"\" width=\"auto\"/></span></span></p>\n<p>Although the target threshold should be an unsigned integer, the original nBits implementation inherits properties from a signed data class, allowing the target threshold to be negative if the high bit of the significand is set. This is useless---the header hash is treated as an unsigned number, so it can never be equal to or lower than a negative target threshold. Dash Core deals with this in two ways:</p>\n<ul>\n<li>\n<p>When parsing nBits, Dash Core converts a negative target threshold into a target of zero, which the header hash can equal (in theory, at least).</p>\n</li>\n<li>\n<p>When creating a value for nBits, Dash Core checks to see if it will produce an nBits which will be interpreted as negative; if so, it divides the significand by 256 and increases the exponent by 1 to   produce the same number with a different encoding.</p>\n</li>\n</ul>\n<p>Some examples taken from the Dash Core test cases:</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<div class=\"rdmd-table\"><div class=\"rdmd-table-inner\"><table><thead><tr><th>nBits</th><th>Target</th><th>Notes</th></tr></thead><tbody><tr><td>0x01003456</td><td>\u00a00x00</td><td></td></tr><tr><td>0x01123456</td><td>\u00a00x12</td><td></td></tr><tr><td>0x02008000</td><td>\u00a00x80</td><td></td></tr><tr><td>0x05009234</td><td>\u00a00x92340000</td><td></td></tr><tr><td>0x04923456</td><td>-0x12345600</td><td>High bit set (0x80 in 0x92).</td></tr><tr><td>0x04123456</td><td>\u00a00x12345600</td><td>Inverse of above; no high bit.</td></tr></tbody></table></div></div>\n<p>Difficulty 1, the minimum allowed <span class=\"GlossaryItem-trigger\">difficulty</span>, is represented on <span class=\"GlossaryItem-trigger\">mainnet</span> and the current <span class=\"GlossaryItem-trigger\">testnet</span> by the nBits value 0x1e0ffff0. Regtest mode uses a different difficulty 1 value---0x207fffff, the highest possible value below uint32_max which can be encoded; this allows near-instant building of blocks in <span class=\"GlossaryItem-trigger\">regression test mode</span>.</p>"
}