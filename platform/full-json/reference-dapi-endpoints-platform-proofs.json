{
 "pendingAlgoliaPublish": false, 
 "parentDoc": "60e604b4762bd40057ebe11b", 
 "excerpt": "", 
 "api": {
  "url": "", 
  "params": [], 
  "method": "get", 
  "auth": "required", 
  "results": {
   "codes": [
    {
     "status": 200, 
     "code": "{}", 
     "name": "", 
     "language": "json"
    }, 
    {
     "status": 400, 
     "code": "{}", 
     "name": "", 
     "language": "json"
    }
   ]
  }
 }, 
 "previousSlug": "", 
 "updatedAt": "2021-07-22T17:43:52.919Z", 
 "id": "60f83860e4f5e000486ac965", 
 "sync_unique": "", 
 "isApi": false, 
 "createdAt": "2021-07-21T15:08:16.595Z", 
 "category": "60e604b4762bd40057ebe0dc", 
 "title": "Platform Proofs", 
 "next": {
  "description": "", 
  "pages": []
 }, 
 "version": "60e604b4762bd40057ebe142", 
 "slugUpdatedAt": "2021-07-21T15:06:07.560Z", 
 "hidden": false, 
 "type": "basic", 
 "metadata": {
  "image": [], 
  "description": "", 
  "title": ""
 }, 
 "body": "Since data verification is a critical aspect of Dash Platform, all [Platform endpoints](reference-dapi-endpoints-platform-endpoints) can provide an optional proof that the response is correct. Set the optional `prove` parameter (`\"prove\": true`) in the request to receive a proof that contains the requested data.\n\n# Proof Structure\n\nEach proof consists of four parts:\n\n| Field | Type | Description |\n|-|-|-|\n| rootTreeProof | Bytes (base64) | Merkle path to the `storeTreeProof` |\n| [storeTreeProof](#store-tree-proof) | Bytes (base64) | Merk tree proof containing the store root hash, the merkle path, and the requested data |\n| signatureLlmqHash | Bytes (base64) | Hash of the LLMQ that created the `signature` |\n| signature | Bytes (base64) | Signature of the merkle root of the `rootTreeProof` |\n[block:code]\n{\n  \"codes\": [\n    {\n      \"code\": \"{\\n  \\\"proof\\\": {\\n    \\\"rootTreeProof\\\": \\\"AQAAAANDyOH1e+nnMfZAiT9W6O8bnSwNt7ExdoPORAjOOQl1hncTjwAKTjkBt9itDASm0uhlmZTIAE7qaorXXpW9W4TMJu/rY51+fQEeMotzZc6ndsHCaWC3rvrAWkzYni1iBYgBBQ==\\\",\\n    \\\"storeTreeProof\\\": \\\"Aa3xeZMhgUlpOmObZgsBc/A7Tw8DiE7Al0d8UnlPKDxEAkxb4mgZiSCI/Dww08L/Kypsf9zOSuQ9pbuCf1+iLKo2EAFJN2x17KAW3m6kfE4Vbv2sI5P9cRgajTYzLrYc41t5VRE=\\\",\\n    \\\"signatureLlmqHash\\\": \\\"AAABDRGoCpOki/CVlNkMeQhapUFyIoXOESFPn1cXK6I=\\\",\\n    \\\"signature\\\": \\\"AU+FZUCH/OKrM8GuNo0L8S+mKCpbAe/f9SJ1V3fhudrlOja1KislQRcBbIShk74bGLvN8exT/6BVxPHQtaM+LDqfuZGXG1EmgNGY2827/Pyn8XGtP2jDmuhvonCRD4QN\\\"\\n  },\\n  \\\"metadata\\\": {\\n    \\\"height\\\": 433,\\n    \\\"coreChainLockedHeight\\\": 9801\\n  }\\n}\\n\",\n      \"language\": \"json\",\n      \"name\": \"Example Response with Proof\"\n    }\n  ]\n}\n[/block]\n## Root tree proof\n[block:callout]\n{\n  \"type\": \"info\",\n  \"body\": \"Details regarding the root tree proofs and their verification will be provided in a future update to this page.\"\n}\n[/block]\n## Store tree proof\n\nStore tree proofs are based on a modified version of [Merk](https://github.com/nomic-io/merk/). Some details from the Merk documentation are included below. Additional details are available in the [Algorithms document](https://github.com/nomic-io/merk/blob/develop/docs/algorithms.md) on the Merk repository.\n\n### Structure \n\nMerk proofs are a list of stack-based operators and node data, with 3 possible operators: `Push(node)`, `Parent`, and `Child`. A stream of these operators can be processed by a verifier in order to reconstruct a sparse representation of part of the tree, in a way where the data can be verified against a known root hash.\n\nThe value of `node` in a `Push` operation can be one of three types:\n\n* `Hash(hash)` - The hash of a node\n* `KVHash(hash)` - The key/value hash of a node\n* `KV(key, value)` - The key and value of a node\n\n### Binary Format\n\nWe can efficiently encode these proofs by encoding each operator as follows:\n\n| Operator | Op. Value | Size | Description |\n|-|:-:|-|-|\n| Push(Hash(hash)) | `0x01` | 32 bytes | Node hash |\n| Push(KVHash(hash)) | `0x02` | 32 bytes | Node key/value hash |\n| Push(KV(key, value)) | `0x03` | < 1-byte key length ><br>< n-byte key ><br>< 2-byte value length ><br>< n-byte value > | Node key/value |\n\nThis results in a compact binary representation, with a very small space overhead (roughly 2 bytes per node in the proof (1 byte for the Push operator type flag, and 1 byte for a Parent or Child operator), plus 3 bytes per key/value pair (1 byte for the key length, and 2 bytes for the value length)).\n\n# Retrieving response data from proofs\n\nThe function below shows a simple example of parsing a response's `storeTreeProof` to retrieve the data asked for by the request:\n[block:code]\n{\n  \"codes\": [\n    {\n      \"code\": \"// Get data from base64 encoded store tree proof\\nfunction getStoreProofData(storeProof) {\\n  const buf = Buffer.from(storeProof, 'base64');\\n\\n  let x = 0;\\n  let valueFound = false;\\n  while (x < buf.length) {\\n    const type = buf.readUInt8(x);\\n    x += 1;\\n\\n    switch (type) {\\n      case 0x01: { // Hash\\n        x += hashLength;\\n        break;\\n      }\\n\\n      case 0x02: { // Key/value hash\\n        x += hashLength;\\n        break;\\n      }\\n\\n      case 0x03: { // Key / Value\\n        const keySize = buf.readUInt8(x);\\n        x += 1;\\n        x += keySize;\\n\\n        const valueSize = buf.readUInt16BE(x);\\n        x += 2;\\n\\n        // Value\\n        const value = buf.toString('hex', x, x + valueSize);\\n        x += valueSize;\\n        const map = cbor.decode(value);\\n\\n        valueFound = true;\\n        return map;\\n      }\\n\\n      case 0x10: // Parent\\n        break;\\n\\n      case 0x11: // Child\\n        break;\\n\\n      default:\\n        console.log(`Unknown type: ${type.toString(16)}`);\\n        break;\\n    }\\n  }\\n  console.log(`Value found: ${valueFound}`);\\n}\",\n      \"language\": \"javascript\"\n    }\n  ]\n}\n[/block]", 
 "link_external": false, 
 "body_html": "<div class=\"magic-block-textarea\"><p>Since data verification is a critical aspect of Dash Platform, all <a href=\"reference-dapi-endpoints-platform-endpoints\">Platform endpoints</a> can provide an optional proof that the response is correct. Set the optional <code>prove</code> parameter (<code>&quot;prove&quot;: true</code>) in the request to receive a proof that contains the requested data.</p>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-proof-structure\"></div>Proof Structure<a class=\"fa fa-anchor\" href=\"#section-proof-structure\"></a></h1>\n<p>Each proof consists of four parts:</p>\n<div class=\"marked-table\"><table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rootTreeProof</td>\n<td>Bytes (base64)</td>\n<td>Merkle path to the <code>storeTreeProof</code></td>\n</tr>\n<tr>\n<td><a href=\"#store-tree-proof\">storeTreeProof</a></td>\n<td>Bytes (base64)</td>\n<td>Merk tree proof containing the store root hash, the merkle path, and the requested data</td>\n</tr>\n<tr>\n<td>signatureLlmqHash</td>\n<td>Bytes (base64)</td>\n<td>Hash of the LLMQ that created the <code>signature</code></td>\n</tr>\n<tr>\n<td>signature</td>\n<td>Bytes (base64)</td>\n<td>Signature of the merkle root of the <code>rootTreeProof</code></td>\n</tr>\n</tbody>\n</table></div>\n\n</div>\n<div class=\"magic-block-code\">\n\t<ul class=\"block-code-header\">\n\t\t<li><a href=\"\" ng-click=\"showCode(0)\" ng-class=\"{active: (0 == tab)}\">Example Response with Proof</a></li>\n\t</ul>\n\t<div class=\"block-code-code\"><span ng-if=\"tab == 0\">\n\t\t\t<button ng-click=\"copyCode(829)\" class=\"copy-code-button\"><span ng-show=\"!copied\" class=\"fa fa-clipboard\"></span><span ng-show=\"copied\" class=\"fa fa-check\"></span></button>\n\t\t\t<textarea ng-non-bindable=\"ng-non-bindable\" style=\"position: absolute; left: -10000px;\" id=\"text-code-829\">{\n  &quot;proof&quot;: {\n    &quot;rootTreeProof&quot;: &quot;AQAAAANDyOH1e+nnMfZAiT9W6O8bnSwNt7ExdoPORAjOOQl1hncTjwAKTjkBt9itDASm0uhlmZTIAE7qaorXXpW9W4TMJu/rY51+fQEeMotzZc6ndsHCaWC3rvrAWkzYni1iBYgBBQ==&quot;,\n    &quot;storeTreeProof&quot;: &quot;Aa3xeZMhgUlpOmObZgsBc/A7Tw8DiE7Al0d8UnlPKDxEAkxb4mgZiSCI/Dww08L/Kypsf9zOSuQ9pbuCf1+iLKo2EAFJN2x17KAW3m6kfE4Vbv2sI5P9cRgajTYzLrYc41t5VRE=&quot;,\n    &quot;signatureLlmqHash&quot;: &quot;AAABDRGoCpOki/CVlNkMeQhapUFyIoXOESFPn1cXK6I=&quot;,\n    &quot;signature&quot;: &quot;AU+FZUCH/OKrM8GuNo0L8S+mKCpbAe/f9SJ1V3fhudrlOja1KislQRcBbIShk74bGLvN8exT/6BVxPHQtaM+LDqfuZGXG1EmgNGY2827/Pyn8XGtP2jDmuhvonCRD4QN&quot;\n  },\n  &quot;metadata&quot;: {\n    &quot;height&quot;: 433,\n    &quot;coreChainLockedHeight&quot;: 9801\n  }\n}\n</textarea>\n\t\t\t<pre id=\"code-829\"><code><span class='cm-s-neo'>{\n  <span class=\"cm-property\">\"proof\"</span>: {\n    <span class=\"cm-property\">\"rootTreeProof\"</span>: <span class=\"cm-string\">\"AQAAAANDyOH1e+nnMfZAiT9W6O8bnSwNt7ExdoPORAjOOQl1hncTjwAKTjkBt9itDASm0uhlmZTIAE7qaorXXpW9W4TMJu&#47;rY51+fQEeMotzZc6ndsHCaWC3rvrAWkzYni1iBYgBBQ==\"</span>,\n    <span class=\"cm-property\">\"storeTreeProof\"</span>: <span class=\"cm-string\">\"Aa3xeZMhgUlpOmObZgsBc&#47;A7Tw8DiE7Al0d8UnlPKDxEAkxb4mgZiSCI&#47;Dww08L&#47;Kypsf9zOSuQ9pbuCf1+iLKo2EAFJN2x17KAW3m6kfE4Vbv2sI5P9cRgajTYzLrYc41t5VRE=\"</span>,\n    <span class=\"cm-property\">\"signatureLlmqHash\"</span>: <span class=\"cm-string\">\"AAABDRGoCpOki&#47;CVlNkMeQhapUFyIoXOESFPn1cXK6I=\"</span>,\n    <span class=\"cm-property\">\"signature\"</span>: <span class=\"cm-string\">\"AU+FZUCH&#47;OKrM8GuNo0L8S+mKCpbAe&#47;f9SJ1V3fhudrlOja1KislQRcBbIShk74bGLvN8exT&#47;6BVxPHQtaM+LDqfuZGXG1EmgNGY2827&#47;Pyn8XGtP2jDmuhvonCRD4QN\"</span>\n  },\n  <span class=\"cm-property\">\"metadata\"</span>: {\n    <span class=\"cm-property\">\"height\"</span>: <span class=\"cm-number\">433</span>,\n    <span class=\"cm-property\">\"coreChainLockedHeight\"</span>: <span class=\"cm-number\">9801</span>\n  }\n}\n</span></code></pre></span>\n\t</div>\n</div>\n<div class=\"magic-block-textarea\"><h2 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-root-tree-proof\"></div>Root tree proof<a class=\"fa fa-anchor\" href=\"#section-root-tree-proof\"></a></h2>\n\n</div>\n<div class=\"magic-block-callout type-info no-title\"><span class=\"noTitleIcon\"><i title=\"Info\" class=\"fa fa-info-circle\"></i></span>\n\t<div class=\"callout-body\"><p>Details regarding the root tree proofs and their verification will be provided in a future update to this page.</p>\n\n\t</div>\n</div>\n<div class=\"magic-block-textarea\"><h2 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-store-tree-proof\"></div>Store tree proof<a class=\"fa fa-anchor\" href=\"#section-store-tree-proof\"></a></h2>\n<p>Store tree proofs are based on a modified version of <a href=\"https://github.com/nomic-io/merk/\">Merk</a>. Some details from the Merk documentation are included below. Additional details are available in the <a href=\"https://github.com/nomic-io/merk/blob/develop/docs/algorithms.md\">Algorithms document</a> on the Merk repository.</p>\n<h3 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-structure\"></div>Structure<a class=\"fa fa-anchor\" href=\"#section-structure\"></a></h3>\n<p>Merk proofs are a list of stack-based operators and node data, with 3 possible operators: <code>Push(node)</code>, <code>Parent</code>, and <code>Child</code>. A stream of these operators can be processed by a verifier in order to reconstruct a sparse representation of part of the tree, in a way where the data can be verified against a known root hash.</p>\n<p>The value of <code>node</code> in a <code>Push</code> operation can be one of three types:</p>\n<ul>\n<li ><code>Hash(hash)</code> - The hash of a node</li><li ><code>KVHash(hash)</code> - The key/value hash of a node</li><li ><code>KV(key, value)</code> - The key and value of a node</li></ul>\n<h3 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-binary-format\"></div>Binary Format<a class=\"fa fa-anchor\" href=\"#section-binary-format\"></a></h3>\n<p>We can efficiently encode these proofs by encoding each operator as follows:</p>\n<div class=\"marked-table\"><table>\n<thead>\n<tr>\n<th>Operator</th>\n<th style=\"text-align:center\">Op. Value</th>\n<th>Size</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Push(Hash(hash))</td>\n<td style=\"text-align:center\"><code>0x01</code></td>\n<td>32 bytes</td>\n<td>Node hash</td>\n</tr>\n<tr>\n<td>Push(KVHash(hash))</td>\n<td style=\"text-align:center\"><code>0x02</code></td>\n<td>32 bytes</td>\n<td>Node key/value hash</td>\n</tr>\n<tr>\n<td>Push(KV(key, value))</td>\n<td style=\"text-align:center\"><code>0x03</code></td>\n<td>&lt; 1-byte key length &gt;<br>&lt; n-byte key &gt;<br>&lt; 2-byte value length &gt;<br>&lt; n-byte value &gt;</td>\n<td>Node key/value</td>\n</tr>\n</tbody>\n</table></div>\n<p>This results in a compact binary representation, with a very small space overhead (roughly 2 bytes per node in the proof (1 byte for the Push operator type flag, and 1 byte for a Parent or Child operator), plus 3 bytes per key/value pair (1 byte for the key length, and 2 bytes for the value length)).</p>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-retrieving-response-data-from-proofs\"></div>Retrieving response data from proofs<a class=\"fa fa-anchor\" href=\"#section-retrieving-response-data-from-proofs\"></a></h1>\n<p>The function below shows a simple example of parsing a response&#39;s <code>storeTreeProof</code> to retrieve the data asked for by the request:</p>\n\n</div>\n<div class=\"magic-block-code\">\n\t<ul class=\"block-code-header\">\n\t\t<li><a href=\"\" ng-click=\"showCode(0)\" ng-class=\"{active: (0 == tab)}\">JavaScript</a></li>\n\t</ul>\n\t<div class=\"block-code-code\"><span ng-if=\"tab == 0\">\n\t\t\t<button ng-click=\"copyCode(37)\" class=\"copy-code-button\"><span ng-show=\"!copied\" class=\"fa fa-clipboard\"></span><span ng-show=\"copied\" class=\"fa fa-check\"></span></button>\n\t\t\t<textarea ng-non-bindable=\"ng-non-bindable\" style=\"position: absolute; left: -10000px;\" id=\"text-code-37\">// Get data from base64 encoded store tree proof\nfunction getStoreProofData(storeProof) {\n  const buf = Buffer.from(storeProof, 'base64');\n\n  let x = 0;\n  let valueFound = false;\n  while (x &lt; buf.length) {\n    const type = buf.readUInt8(x);\n    x += 1;\n\n    switch (type) {\n      case 0x01: { // Hash\n        x += hashLength;\n        break;\n      }\n\n      case 0x02: { // Key/value hash\n        x += hashLength;\n        break;\n      }\n\n      case 0x03: { // Key / Value\n        const keySize = buf.readUInt8(x);\n        x += 1;\n        x += keySize;\n\n        const valueSize = buf.readUInt16BE(x);\n        x += 2;\n\n        // Value\n        const value = buf.toString('hex', x, x + valueSize);\n        x += valueSize;\n        const map = cbor.decode(value);\n\n        valueFound = true;\n        return map;\n      }\n\n      case 0x10: // Parent\n        break;\n\n      case 0x11: // Child\n        break;\n\n      default:\n        console.log(`Unknown type: ${type.toString(16)}`);\n        break;\n    }\n  }\n  console.log(`Value found: ${valueFound}`);\n}</textarea>\n\t\t\t<pre id=\"code-37\"><code><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47; Get data from base64 encoded store tree proof</span>\n<span class=\"cm-keyword\">function</span> <span class=\"cm-def\">getStoreProofData</span>(<span class=\"cm-def\">storeProof</span>) {\n  <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">buf</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">Buffer</span>.<span class=\"cm-property\">from</span>(<span class=\"cm-variable-2\">storeProof</span>, <span class=\"cm-string\">'base64'</span>);\n\n  <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">x</span> <span class=\"cm-operator\">=</span> <span class=\"cm-number\">0</span>;\n  <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">valueFound</span> <span class=\"cm-operator\">=</span> <span class=\"cm-atom\">false</span>;\n  <span class=\"cm-keyword\">while</span> (<span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">&lt;</span> <span class=\"cm-variable-2\">buf</span>.<span class=\"cm-property\">length</span>) {\n    <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">type</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-2\">buf</span>.<span class=\"cm-property\">readUInt8</span>(<span class=\"cm-variable-2\">x</span>);\n    <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-number\">1</span>;\n\n    <span class=\"cm-keyword\">switch</span> (<span class=\"cm-variable-2\">type</span>) {\n      <span class=\"cm-keyword\">case</span> <span class=\"cm-number\">0x01</span>: { <span class=\"cm-comment\">&#47;&#47; Hash</span>\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-variable\">hashLength</span>;\n        <span class=\"cm-keyword\">break</span>;\n      }\n\n      <span class=\"cm-keyword\">case</span> <span class=\"cm-number\">0x02</span>: { <span class=\"cm-comment\">&#47;&#47; Key&#47;value hash</span>\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-variable\">hashLength</span>;\n        <span class=\"cm-keyword\">break</span>;\n      }\n\n      <span class=\"cm-keyword\">case</span> <span class=\"cm-number\">0x03</span>: { <span class=\"cm-comment\">&#47;&#47; Key &#47; Value</span>\n        <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">keySize</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-2\">buf</span>.<span class=\"cm-property\">readUInt8</span>(<span class=\"cm-variable-2\">x</span>);\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-number\">1</span>;\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-variable-2\">keySize</span>;\n\n        <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">valueSize</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-2\">buf</span>.<span class=\"cm-property\">readUInt16BE</span>(<span class=\"cm-variable-2\">x</span>);\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-number\">2</span>;\n\n        <span class=\"cm-comment\">&#47;&#47; Value</span>\n        <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">value</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-2\">buf</span>.<span class=\"cm-property\">toString</span>(<span class=\"cm-string\">'hex'</span>, <span class=\"cm-variable-2\">x</span>, <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+</span> <span class=\"cm-variable-2\">valueSize</span>);\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-variable-2\">valueSize</span>;\n        <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">map</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">cbor</span>.<span class=\"cm-property\">decode</span>(<span class=\"cm-variable-2\">value</span>);\n\n        <span class=\"cm-variable-2\">valueFound</span> <span class=\"cm-operator\">=</span> <span class=\"cm-atom\">true</span>;\n        <span class=\"cm-keyword\">return</span> <span class=\"cm-variable-2\">map</span>;\n      }\n\n      <span class=\"cm-keyword\">case</span> <span class=\"cm-number\">0x10</span>: <span class=\"cm-comment\">&#47;&#47; Parent</span>\n        <span class=\"cm-keyword\">break</span>;\n\n      <span class=\"cm-keyword\">case</span> <span class=\"cm-number\">0x11</span>: <span class=\"cm-comment\">&#47;&#47; Child</span>\n        <span class=\"cm-keyword\">break</span>;\n\n      <span class=\"cm-keyword\">default</span>:\n        <span class=\"cm-variable\">console</span>.<span class=\"cm-property\">log</span>(<span class=\"cm-string-2\">`Unknown type: ${</span><span class=\"cm-variable-2\">type</span>.<span class=\"cm-property\">toString</span>(<span class=\"cm-number\">16</span>)<span class=\"cm-string-2\">}`</span>);\n        <span class=\"cm-keyword\">break</span>;\n    }\n  }\n  <span class=\"cm-variable\">console</span>.<span class=\"cm-property\">log</span>(<span class=\"cm-string-2\">`Value found: ${</span><span class=\"cm-variable-2\">valueFound</span><span class=\"cm-string-2\">}`</span>);\n}</span></code></pre></span>\n\t</div>\n</div>", 
 "user": "5b8400d7185d5e00036dcc3b", 
 "isReference": false, 
 "slug": "reference-dapi-endpoints-platform-proofs", 
 "link_url": "", 
 "project": "5bda01cad172e200499a20a9", 
 "__v": 0, 
 "_id": "60f83860e4f5e000486ac965", 
 "order": 999, 
 "updates": []
}