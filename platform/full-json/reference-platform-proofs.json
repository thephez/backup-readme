{
 "metadata": {
  "image": [],
  "title": "",
  "description": ""
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 200
    },
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 400
    }
   ]
  },
  "params": []
 },
 "next": {
  "description": "",
  "pages": []
 },
 "title": "Platform Proofs",
 "updates": [],
 "type": "basic",
 "slug": "reference-platform-proofs",
 "excerpt": "",
 "body": "Since data verification is a critical aspect of Dash Platform, all [Platform endpoints](reference-dapi-endpoints-platform-endpoints) can provide an optional proof that the response is correct. Set the optional `prove` parameter (`\"prove\": true`) in the request to receive a proof that contains the requested data.\n\n# Proof Structure\n\nEach proof consists of four parts:\n\n| Field | Type | Description |\n|-|-|-|\n| rootTreeProof | Bytes (base64) | Merkle path to the `storeTreeProof` |\n| [storeTreeProof](#store-tree-proof) | Object | Object containing data and proofs from one or more store trees. Currently there are 5 types of trees: identities, public key hash to identity IDs, data contracts, documents, and state transitions. The merk tree proofs contain the store root hash, the merkle path, and the requested data |\n| signatureLlmqHash | Bytes (base64) | Hash of the LLMQ that created the `signature` |\n| signature | Bytes (base64) | Signature of the merkle root of the `rootTreeProof` |\n[block:code]\n{\n  \"codes\": [\n    {\n      \"code\": \"{\\n  \\\"proof\\\": {\\n    \\\"rootTreeProof\\\": \\\"v+99FytmaUPDP65HthQllBL1JDXt2Zu/kzFEQRw66rT6QF8LYwKmAP6fEaXLaSVPe/OHfTDEG2+KoLxjyirQIDmDy4lNl4yhJE5stQZGO2G/74H4MxN/a/luSWkqE1vF\\\",\\n    \\\"storeTreeProofs\\\": {\\n      \\\"identitiesProof\\\": \\\"AeFWk/kp1HXlJMzA4Wwov+NifjrocHebDU8863BDtp4aAlHeCG7lcVi52OSo+U5LlykSjARXJ5Rv6hE+mui+RnUFEAGJ24nuRAkAZMjcRp1sbzLPwYxxagTD12YTLksNN+y1cAKxpoxQdHpC/RQN7cq7fE/z6+0ccpoVQbobRPGtfCSj4hABjDZM5byc2NbfTNb7NGWDKm0bAoZjaAHx+C7Gn2cKmfsCIyWhRVW4QDdnoxTDvJuHCKJeK8dWzsrfVuUYTejcw6MQAX4HE7Y1WuXPPAG6uU9vewbilQnhjLzSTYNVLsdkxmLfAmwhTWaLg5A+tuxnzvdPhNU+bmbyMHr4PIL8Z+ScbyikEAFtCRA34Yl9tuEzqAF1EdiY0U9/jNoyEpU2vkPLO7xUYAJEmc3z/snpNWPXQdMrrAAHqWNhwddPRSMrF0epC75qThADIHwTzudaE/98V8XvldeYDIpe0yZOW3s6iK0jdqsoOJz3AIABAAAApGJpZFggfBPO51oT/3xXxe+V15gMil7TJk5bezqIrSN2qyg4nPdnYmFsYW5jZRoAp8O4aHJldmlzaW9uAGpwdWJsaWNLZXlzgaNiaWQAZGRhdGFYIQOF51gOnYk5T+0EdR4DSKUkDo5TmEDMoMxdxOy7FnqKjmR0eXBlABEREQL0H2yuZyiMzKzHmrXCwp/W7DuDkZYlEx7JE5xlYGhJxhABJt9KcGPXHnE7hzz3aQ9PpYDhvILZCDUOu5BBwV66RPYRERECyX/3Cih/TZdB9cVOX8Xmo2UEPNvt9iOufQ4oCmoytwsQAU14wPdQ7t7FfsfXx9fGnwbZk8h1uxoWd0MroZRO0YVXEQ==\\\",\\n      \\\"publicKeyHashesToIdentityIdsProof\\\": \\\"Afe33zbtlgXiPzJ1+zSjjVttIBmiKHy1iEc7uOKqxVUGAjs/C8gAlTwbVhnRBqbhGFkz0Kg/0Cr8mAV41WXxocBpEAGVsw8werVp7Cka+OSMj3GgkX2Da0FMMGGIJx4aZxPwPhE=\\\"\\n    },\\n    \\\"signatureLlmqHash\\\": \\\"AAACBMSv9TakRGNdP+yvxw/+VCgIbALhn314jLOpgcY=\\\",\\n    \\\"signature\\\": \\\"Fhl8Md9MDlB0Tlekgjoj+Qe5PdKeUDyL6svVmcP9ttRu1UB7oeAGaSMAyqJI+k/HA/jAfPFb9+q9gepdZDhj8zHrl5BRSaAiBPEtM6CTQ+eCWUvqOlDENVQfubrXLLdk\\\"\\n  },\\n  \\\"metadata\\\": {\\n    \\\"height\\\": \\\"7986\\\",\\n    \\\"coreChainLockedHeight\\\": 57585\\n  }\\n}\",\n      \"language\": \"json\",\n      \"name\": \"Example getIdentitiesByPublicKeyHashes Response with Proof\"\n    }\n  ]\n}\n[/block]\n## Root tree proof\n[block:callout]\n{\n  \"type\": \"info\",\n  \"body\": \"Details regarding the root tree proofs and their verification will be provided in a future update to this page.\"\n}\n[/block]\n## Store tree proof\n\nStore tree proofs are based on a modified version of [Merk](https://github.com/nomic-io/merk/). Some details from the Merk documentation are included below. Additional details are available in the [Algorithms document](https://github.com/nomic-io/merk/blob/develop/docs/algorithms.md) on the Merk repository.\n\nDash Platform 0.21.0 introduced updates to support returning multiple store tree proofs. Each response that requests proofs will receive one or more of the following:\n - `identitiesProof`\n - `publicKeyHashesToIdentityIdsProof`\n - `dataContractsProof`\n - `documentsProof`\n - `stateTransitionProof`\n\n[block:callout]\n{\n  \"type\": \"warning\",\n  \"body\": \"Dash Platform 0.21.0 introduced a 4 byte [protocol version](https://github.com/dashevo/js-dpp/pull/325) that is prepended to the binary format and is not part of the CBOR-encoded data. When parsing proofs it is necessary to exclude these bytes before decoding the returned data with CBOR.\",\n  \"title\": \"\"\n}\n[/block]\n### Structure \n\nMerk proofs are a list of stack-based operators and node data, with 3 possible operators: `Push(node)`, `Parent`, and `Child`. A stream of these operators can be processed by a verifier in order to reconstruct a sparse representation of part of the tree, in a way where the data can be verified against a known root hash.\n\nThe value of `node` in a `Push` operation can be one of three types:\n\n* `Hash(hash)` - The hash of a node\n* `KVHash(hash)` - The key/value hash of a node\n* `KV(key, value)` - The key and value of a node\n\n### Binary Format\n\nWe can efficiently encode these proofs by encoding each operator as follows:\n\n| Operator | Op. Value | Size | Description |\n|-|:-:|-|-|\n| Push(Hash(hash)) | `0x01` | 32 bytes | Node hash |\n| Push(KVHash(hash)) | `0x02` | 32 bytes | Node key/value hash |\n| Push(KV(key, value)) | `0x03` | < 1-byte key length ><br>< n-byte key ><br>< 2-byte value length ><br>< n-byte value > | Node key/value |\n\nThis results in a compact binary representation, with a very small space overhead (roughly 2 bytes per node in the proof (1 byte for the Push operator type flag, and 1 byte for a Parent or Child operator), plus 3 bytes per key/value pair (1 byte for the key length, and 2 bytes for the value length)).\n\n# Retrieving response data from proofs\n\nThe function below shows a simple example of parsing a response's `storeTreeProof` to retrieve the data asked for by the request:\n[block:code]\n{\n  \"codes\": [\n    {\n      \"code\": \"// Get data from base64 encoded store tree proof\\nfunction getStoreProofData(storeProof) {\\n  const values = [];\\n  const buf = Buffer.from(storeProof, 'base64');\\n\\n  let x = 0;\\n  let valueFound = false;\\n  while (x < buf.length) {\\n    const type = buf.readUInt8(x);\\n    x += 1;\\n\\n    switch (type) {\\n      case 0x01: { // Hash\\n        x += hashLength;\\n        break;\\n      }\\n\\n      case 0x02: { // Key/value hash\\n        x += hashLength;\\n        break;\\n      }\\n\\n      case 0x03: { // Key / Value\\n        const keySize = buf.readUInt8(x);\\n        x += (1 + keySize);\\n\\n        const valueSize = buf.readUInt16BE(x);\\n        x += 2;\\n\\n        // Value\\n        // Start at x+4 because the first 4 bytes are the protocol version\\n        // and are not part of the CBOR value\\n        const value = buf.toString('hex', x + 4, x + valueSize);\\n        x += valueSize;\\n        const map = cbor.decode(value);\\n\\n        valueFound = true;\\n        values.push(map);\\n        break;\\n      }\\n\\n      case 0x10: // Parent\\n        break;\\n\\n      case 0x11: // Child\\n        break;\\n\\n      default:\\n        console.log(`Unknown type: ${type.toString(16)}`);\\n        break;\\n    }\\n  }\\n  console.log(`Value found: ${valueFound}`);\\n  return values;\\n}\",\n      \"language\": \"javascript\"\n    }\n  ]\n}\n[/block]",
 "order": 3,
 "isReference": false,
 "deprecated": false,
 "hidden": false,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "pendingAlgoliaPublish": false,
 "previousSlug": "reference-dapi-endpoints-platform-proofs",
 "slugUpdatedAt": "2021-10-07T13:29:19.625Z",
 "_id": "612fe724e9fa2b0026f5facd",
 "createdAt": "2021-07-21T15:08:16.595Z",
 "updatedAt": "2021-10-06T19:20:24.491Z",
 "user": "5b8400d7185d5e00036dcc3b",
 "parentDoc": null,
 "category": "612fe724e9fa2b0026f5fa67",
 "project": "5bda01cad172e200499a20a9",
 "version": "612fe724e9fa2b0026f5face",
 "__v": 0,
 "isApi": false,
 "id": "612fe724e9fa2b0026f5facd",
 "body_html": "<div class=\"magic-block-textarea\"><p>Since data verification is a critical aspect of Dash Platform, all <a href=\"reference-dapi-endpoints-platform-endpoints\">Platform endpoints</a> can provide an optional proof that the response is correct. Set the optional <code>prove</code> parameter (<code>&quot;prove&quot;: true</code>) in the request to receive a proof that contains the requested data.</p>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-proof-structure\"></div>Proof Structure<a class=\"fa fa-anchor\" href=\"#section-proof-structure\"></a></h1>\n<p>Each proof consists of four parts:</p>\n<div class=\"marked-table\"><table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rootTreeProof</td>\n<td>Bytes (base64)</td>\n<td>Merkle path to the <code>storeTreeProof</code></td>\n</tr>\n<tr>\n<td><a href=\"#store-tree-proof\">storeTreeProof</a></td>\n<td>Object</td>\n<td>Object containing data and proofs from one or more store trees. Currently there are 5 types of trees: identities, public key hash to identity IDs, data contracts, documents, and state transitions. The merk tree proofs contain the store root hash, the merkle path, and the requested data</td>\n</tr>\n<tr>\n<td>signatureLlmqHash</td>\n<td>Bytes (base64)</td>\n<td>Hash of the LLMQ that created the <code>signature</code></td>\n</tr>\n<tr>\n<td>signature</td>\n<td>Bytes (base64)</td>\n<td>Signature of the merkle root of the <code>rootTreeProof</code></td>\n</tr>\n</tbody>\n</table></div>\n\n</div>\n<div class=\"magic-block-code\">\n\t<ul class=\"block-code-header\">\n\t\t<li><a href=\"\" ng-click=\"showCode(0)\" ng-class=\"{active: (0 == tab)}\">Example getIdentitiesByPublicKeyHashes Response with Proof</a></li>\n\t</ul>\n\t<div class=\"block-code-code\"><span ng-if=\"tab == 0\">\n\t\t\t<button ng-click=\"copyCode(909)\" class=\"copy-code-button\"><span ng-show=\"!copied\" class=\"fa fa-clipboard\"></span><span ng-show=\"copied\" class=\"fa fa-check\"></span></button>\n\t\t\t<textarea ng-non-bindable=\"ng-non-bindable\" style=\"position: absolute; left: -10000px;\" id=\"text-code-909\">{\n  &quot;proof&quot;: {\n    &quot;rootTreeProof&quot;: &quot;v+99FytmaUPDP65HthQllBL1JDXt2Zu/kzFEQRw66rT6QF8LYwKmAP6fEaXLaSVPe/OHfTDEG2+KoLxjyirQIDmDy4lNl4yhJE5stQZGO2G/74H4MxN/a/luSWkqE1vF&quot;,\n    &quot;storeTreeProofs&quot;: {\n      &quot;identitiesProof&quot;: &quot;AeFWk/kp1HXlJMzA4Wwov+NifjrocHebDU8863BDtp4aAlHeCG7lcVi52OSo+U5LlykSjARXJ5Rv6hE+mui+RnUFEAGJ24nuRAkAZMjcRp1sbzLPwYxxagTD12YTLksNN+y1cAKxpoxQdHpC/RQN7cq7fE/z6+0ccpoVQbobRPGtfCSj4hABjDZM5byc2NbfTNb7NGWDKm0bAoZjaAHx+C7Gn2cKmfsCIyWhRVW4QDdnoxTDvJuHCKJeK8dWzsrfVuUYTejcw6MQAX4HE7Y1WuXPPAG6uU9vewbilQnhjLzSTYNVLsdkxmLfAmwhTWaLg5A+tuxnzvdPhNU+bmbyMHr4PIL8Z+ScbyikEAFtCRA34Yl9tuEzqAF1EdiY0U9/jNoyEpU2vkPLO7xUYAJEmc3z/snpNWPXQdMrrAAHqWNhwddPRSMrF0epC75qThADIHwTzudaE/98V8XvldeYDIpe0yZOW3s6iK0jdqsoOJz3AIABAAAApGJpZFggfBPO51oT/3xXxe+V15gMil7TJk5bezqIrSN2qyg4nPdnYmFsYW5jZRoAp8O4aHJldmlzaW9uAGpwdWJsaWNLZXlzgaNiaWQAZGRhdGFYIQOF51gOnYk5T+0EdR4DSKUkDo5TmEDMoMxdxOy7FnqKjmR0eXBlABEREQL0H2yuZyiMzKzHmrXCwp/W7DuDkZYlEx7JE5xlYGhJxhABJt9KcGPXHnE7hzz3aQ9PpYDhvILZCDUOu5BBwV66RPYRERECyX/3Cih/TZdB9cVOX8Xmo2UEPNvt9iOufQ4oCmoytwsQAU14wPdQ7t7FfsfXx9fGnwbZk8h1uxoWd0MroZRO0YVXEQ==&quot;,\n      &quot;publicKeyHashesToIdentityIdsProof&quot;: &quot;Afe33zbtlgXiPzJ1+zSjjVttIBmiKHy1iEc7uOKqxVUGAjs/C8gAlTwbVhnRBqbhGFkz0Kg/0Cr8mAV41WXxocBpEAGVsw8werVp7Cka+OSMj3GgkX2Da0FMMGGIJx4aZxPwPhE=&quot;\n    },\n    &quot;signatureLlmqHash&quot;: &quot;AAACBMSv9TakRGNdP+yvxw/+VCgIbALhn314jLOpgcY=&quot;,\n    &quot;signature&quot;: &quot;Fhl8Md9MDlB0Tlekgjoj+Qe5PdKeUDyL6svVmcP9ttRu1UB7oeAGaSMAyqJI+k/HA/jAfPFb9+q9gepdZDhj8zHrl5BRSaAiBPEtM6CTQ+eCWUvqOlDENVQfubrXLLdk&quot;\n  },\n  &quot;metadata&quot;: {\n    &quot;height&quot;: &quot;7986&quot;,\n    &quot;coreChainLockedHeight&quot;: 57585\n  }\n}</textarea>\n\t\t\t<pre id=\"code-909\"><code><span class='cm-s-neo'>{\n  <span class=\"cm-property\">\"proof\"</span>: {\n    <span class=\"cm-property\">\"rootTreeProof\"</span>: <span class=\"cm-string\">\"v+99FytmaUPDP65HthQllBL1JDXt2Zu&#47;kzFEQRw66rT6QF8LYwKmAP6fEaXLaSVPe&#47;OHfTDEG2+KoLxjyirQIDmDy4lNl4yhJE5stQZGO2G&#47;74H4MxN&#47;a&#47;luSWkqE1vF\"</span>,\n    <span class=\"cm-property\">\"storeTreeProofs\"</span>: {\n      <span class=\"cm-property\">\"identitiesProof\"</span>: <span class=\"cm-string\">\"AeFWk&#47;kp1HXlJMzA4Wwov+NifjrocHebDU8863BDtp4aAlHeCG7lcVi52OSo+U5LlykSjARXJ5Rv6hE+mui+RnUFEAGJ24nuRAkAZMjcRp1sbzLPwYxxagTD12YTLksNN+y1cAKxpoxQdHpC&#47;RQN7cq7fE&#47;z6+0ccpoVQbobRPGtfCSj4hABjDZM5byc2NbfTNb7NGWDKm0bAoZjaAHx+C7Gn2cKmfsCIyWhRVW4QDdnoxTDvJuHCKJeK8dWzsrfVuUYTejcw6MQAX4HE7Y1WuXPPAG6uU9vewbilQnhjLzSTYNVLsdkxmLfAmwhTWaLg5A+tuxnzvdPhNU+bmbyMHr4PIL8Z+ScbyikEAFtCRA34Yl9tuEzqAF1EdiY0U9&#47;jNoyEpU2vkPLO7xUYAJEmc3z&#47;snpNWPXQdMrrAAHqWNhwddPRSMrF0epC75qThADIHwTzudaE&#47;98V8XvldeYDIpe0yZOW3s6iK0jdqsoOJz3AIABAAAApGJpZFggfBPO51oT&#47;3xXxe+V15gMil7TJk5bezqIrSN2qyg4nPdnYmFsYW5jZRoAp8O4aHJldmlzaW9uAGpwdWJsaWNLZXlzgaNiaWQAZGRhdGFYIQOF51gOnYk5T+0EdR4DSKUkDo5TmEDMoMxdxOy7FnqKjmR0eXBlABEREQL0H2yuZyiMzKzHmrXCwp&#47;W7DuDkZYlEx7JE5xlYGhJxhABJt9KcGPXHnE7hzz3aQ9PpYDhvILZCDUOu5BBwV66RPYRERECyX&#47;3Cih&#47;TZdB9cVOX8Xmo2UEPNvt9iOufQ4oCmoytwsQAU14wPdQ7t7FfsfXx9fGnwbZk8h1uxoWd0MroZRO0YVXEQ==\"</span>,\n      <span class=\"cm-property\">\"publicKeyHashesToIdentityIdsProof\"</span>: <span class=\"cm-string\">\"Afe33zbtlgXiPzJ1+zSjjVttIBmiKHy1iEc7uOKqxVUGAjs&#47;C8gAlTwbVhnRBqbhGFkz0Kg&#47;0Cr8mAV41WXxocBpEAGVsw8werVp7Cka+OSMj3GgkX2Da0FMMGGIJx4aZxPwPhE=\"</span>\n    },\n    <span class=\"cm-property\">\"signatureLlmqHash\"</span>: <span class=\"cm-string\">\"AAACBMSv9TakRGNdP+yvxw&#47;+VCgIbALhn314jLOpgcY=\"</span>,\n    <span class=\"cm-property\">\"signature\"</span>: <span class=\"cm-string\">\"Fhl8Md9MDlB0Tlekgjoj+Qe5PdKeUDyL6svVmcP9ttRu1UB7oeAGaSMAyqJI+k&#47;HA&#47;jAfPFb9+q9gepdZDhj8zHrl5BRSaAiBPEtM6CTQ+eCWUvqOlDENVQfubrXLLdk\"</span>\n  },\n  <span class=\"cm-property\">\"metadata\"</span>: {\n    <span class=\"cm-property\">\"height\"</span>: <span class=\"cm-string\">\"7986\"</span>,\n    <span class=\"cm-property\">\"coreChainLockedHeight\"</span>: <span class=\"cm-number\">57585</span>\n  }\n}</span></code></pre></span>\n\t</div>\n</div>\n<div class=\"magic-block-textarea\"><h2 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-root-tree-proof\"></div>Root tree proof<a class=\"fa fa-anchor\" href=\"#section-root-tree-proof\"></a></h2>\n\n</div>\n<div class=\"magic-block-callout type-info no-title\"><span class=\"noTitleIcon\"><i title=\"Info\" class=\"fa fa-info-circle\"></i></span>\n\t<div class=\"callout-body\"><p>Details regarding the root tree proofs and their verification will be provided in a future update to this page.</p>\n\n\t</div>\n</div>\n<div class=\"magic-block-textarea\"><h2 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-store-tree-proof\"></div>Store tree proof<a class=\"fa fa-anchor\" href=\"#section-store-tree-proof\"></a></h2>\n<p>Store tree proofs are based on a modified version of <a href=\"https://github.com/nomic-io/merk/\">Merk</a>. Some details from the Merk documentation are included below. Additional details are available in the <a href=\"https://github.com/nomic-io/merk/blob/develop/docs/algorithms.md\">Algorithms document</a> on the Merk repository.</p>\n<p>Dash Platform 0.21.0 introduced updates to support returning multiple store tree proofs. Each response that requests proofs will receive one or more of the following:</p>\n<ul>\n<li ><code>identitiesProof</code></li><li ><code>publicKeyHashesToIdentityIdsProof</code></li><li ><code>dataContractsProof</code></li><li ><code>documentsProof</code></li><li ><code>stateTransitionProof</code></li></ul>\n\n</div>\n<div class=\"magic-block-callout type-warning no-title\"><span class=\"noTitleIcon\"><i title=\"Warning\" class=\"fa fa-exclamation-circle\"></i></span>\n\t<div class=\"callout-body\"><p>Dash Platform 0.21.0 introduced a 4 byte <a href=\"https://github.com/dashevo/js-dpp/pull/325\">protocol version</a> that is prepended to the binary format and is not part of the CBOR-encoded data. When parsing proofs it is necessary to exclude these bytes before decoding the returned data with CBOR.</p>\n\n\t</div>\n</div>\n<div class=\"magic-block-textarea\"><h3 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-structure\"></div>Structure<a class=\"fa fa-anchor\" href=\"#section-structure\"></a></h3>\n<p>Merk proofs are a list of stack-based operators and node data, with 3 possible operators: <code>Push(node)</code>, <code>Parent</code>, and <code>Child</code>. A stream of these operators can be processed by a verifier in order to reconstruct a sparse representation of part of the tree, in a way where the data can be verified against a known root hash.</p>\n<p>The value of <code>node</code> in a <code>Push</code> operation can be one of three types:</p>\n<ul>\n<li ><code>Hash(hash)</code> - The hash of a node</li><li ><code>KVHash(hash)</code> - The key/value hash of a node</li><li ><code>KV(key, value)</code> - The key and value of a node</li></ul>\n<h3 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-binary-format\"></div>Binary Format<a class=\"fa fa-anchor\" href=\"#section-binary-format\"></a></h3>\n<p>We can efficiently encode these proofs by encoding each operator as follows:</p>\n<div class=\"marked-table\"><table>\n<thead>\n<tr>\n<th>Operator</th>\n<th style=\"text-align:center\">Op. Value</th>\n<th>Size</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Push(Hash(hash))</td>\n<td style=\"text-align:center\"><code>0x01</code></td>\n<td>32 bytes</td>\n<td>Node hash</td>\n</tr>\n<tr>\n<td>Push(KVHash(hash))</td>\n<td style=\"text-align:center\"><code>0x02</code></td>\n<td>32 bytes</td>\n<td>Node key/value hash</td>\n</tr>\n<tr>\n<td>Push(KV(key, value))</td>\n<td style=\"text-align:center\"><code>0x03</code></td>\n<td>&lt; 1-byte key length &gt;<br>&lt; n-byte key &gt;<br>&lt; 2-byte value length &gt;<br>&lt; n-byte value &gt;</td>\n<td>Node key/value</td>\n</tr>\n</tbody>\n</table></div>\n<p>This results in a compact binary representation, with a very small space overhead (roughly 2 bytes per node in the proof (1 byte for the Push operator type flag, and 1 byte for a Parent or Child operator), plus 3 bytes per key/value pair (1 byte for the key length, and 2 bytes for the value length)).</p>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-retrieving-response-data-from-proofs\"></div>Retrieving response data from proofs<a class=\"fa fa-anchor\" href=\"#section-retrieving-response-data-from-proofs\"></a></h1>\n<p>The function below shows a simple example of parsing a response&#39;s <code>storeTreeProof</code> to retrieve the data asked for by the request:</p>\n\n</div>\n<div class=\"magic-block-code\">\n\t<ul class=\"block-code-header\">\n\t\t<li><a href=\"\" ng-click=\"showCode(0)\" ng-class=\"{active: (0 == tab)}\">JavaScript</a></li>\n\t</ul>\n\t<div class=\"block-code-code\"><span ng-if=\"tab == 0\">\n\t\t\t<button ng-click=\"copyCode(920)\" class=\"copy-code-button\"><span ng-show=\"!copied\" class=\"fa fa-clipboard\"></span><span ng-show=\"copied\" class=\"fa fa-check\"></span></button>\n\t\t\t<textarea ng-non-bindable=\"ng-non-bindable\" style=\"position: absolute; left: -10000px;\" id=\"text-code-920\">// Get data from base64 encoded store tree proof\nfunction getStoreProofData(storeProof) {\n  const values = [];\n  const buf = Buffer.from(storeProof, 'base64');\n\n  let x = 0;\n  let valueFound = false;\n  while (x &lt; buf.length) {\n    const type = buf.readUInt8(x);\n    x += 1;\n\n    switch (type) {\n      case 0x01: { // Hash\n        x += hashLength;\n        break;\n      }\n\n      case 0x02: { // Key/value hash\n        x += hashLength;\n        break;\n      }\n\n      case 0x03: { // Key / Value\n        const keySize = buf.readUInt8(x);\n        x += (1 + keySize);\n\n        const valueSize = buf.readUInt16BE(x);\n        x += 2;\n\n        // Value\n        // Start at x+4 because the first 4 bytes are the protocol version\n        // and are not part of the CBOR value\n        const value = buf.toString('hex', x + 4, x + valueSize);\n        x += valueSize;\n        const map = cbor.decode(value);\n\n        valueFound = true;\n        values.push(map);\n        break;\n      }\n\n      case 0x10: // Parent\n        break;\n\n      case 0x11: // Child\n        break;\n\n      default:\n        console.log(`Unknown type: ${type.toString(16)}`);\n        break;\n    }\n  }\n  console.log(`Value found: ${valueFound}`);\n  return values;\n}</textarea>\n\t\t\t<pre id=\"code-920\"><code><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47; Get data from base64 encoded store tree proof</span>\n<span class=\"cm-keyword\">function</span> <span class=\"cm-def\">getStoreProofData</span>(<span class=\"cm-def\">storeProof</span>) {\n  <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">values</span> <span class=\"cm-operator\">=</span> [];\n  <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">buf</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">Buffer</span>.<span class=\"cm-property\">from</span>(<span class=\"cm-variable-2\">storeProof</span>, <span class=\"cm-string\">'base64'</span>);\n\n  <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">x</span> <span class=\"cm-operator\">=</span> <span class=\"cm-number\">0</span>;\n  <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">valueFound</span> <span class=\"cm-operator\">=</span> <span class=\"cm-atom\">false</span>;\n  <span class=\"cm-keyword\">while</span> (<span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">&lt;</span> <span class=\"cm-variable-2\">buf</span>.<span class=\"cm-property\">length</span>) {\n    <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">type</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-2\">buf</span>.<span class=\"cm-property\">readUInt8</span>(<span class=\"cm-variable-2\">x</span>);\n    <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-number\">1</span>;\n\n    <span class=\"cm-keyword\">switch</span> (<span class=\"cm-variable-2\">type</span>) {\n      <span class=\"cm-keyword\">case</span> <span class=\"cm-number\">0x01</span>: { <span class=\"cm-comment\">&#47;&#47; Hash</span>\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-variable\">hashLength</span>;\n        <span class=\"cm-keyword\">break</span>;\n      }\n\n      <span class=\"cm-keyword\">case</span> <span class=\"cm-number\">0x02</span>: { <span class=\"cm-comment\">&#47;&#47; Key&#47;value hash</span>\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-variable\">hashLength</span>;\n        <span class=\"cm-keyword\">break</span>;\n      }\n\n      <span class=\"cm-keyword\">case</span> <span class=\"cm-number\">0x03</span>: { <span class=\"cm-comment\">&#47;&#47; Key &#47; Value</span>\n        <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">keySize</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-2\">buf</span>.<span class=\"cm-property\">readUInt8</span>(<span class=\"cm-variable-2\">x</span>);\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> (<span class=\"cm-number\">1</span> <span class=\"cm-operator\">+</span> <span class=\"cm-variable-2\">keySize</span>);\n\n        <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">valueSize</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-2\">buf</span>.<span class=\"cm-property\">readUInt16BE</span>(<span class=\"cm-variable-2\">x</span>);\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-number\">2</span>;\n\n        <span class=\"cm-comment\">&#47;&#47; Value</span>\n        <span class=\"cm-comment\">&#47;&#47; Start at x+4 because the first 4 bytes are the protocol version</span>\n        <span class=\"cm-comment\">&#47;&#47; and are not part of the CBOR value</span>\n        <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">value</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-2\">buf</span>.<span class=\"cm-property\">toString</span>(<span class=\"cm-string\">'hex'</span>, <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+</span> <span class=\"cm-number\">4</span>, <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+</span> <span class=\"cm-variable-2\">valueSize</span>);\n        <span class=\"cm-variable-2\">x</span> <span class=\"cm-operator\">+=</span> <span class=\"cm-variable-2\">valueSize</span>;\n        <span class=\"cm-keyword\">const</span> <span class=\"cm-def\">map</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">cbor</span>.<span class=\"cm-property\">decode</span>(<span class=\"cm-variable-2\">value</span>);\n\n        <span class=\"cm-variable-2\">valueFound</span> <span class=\"cm-operator\">=</span> <span class=\"cm-atom\">true</span>;\n        <span class=\"cm-variable-2\">values</span>.<span class=\"cm-property\">push</span>(<span class=\"cm-variable-2\">map</span>);\n        <span class=\"cm-keyword\">break</span>;\n      }\n\n      <span class=\"cm-keyword\">case</span> <span class=\"cm-number\">0x10</span>: <span class=\"cm-comment\">&#47;&#47; Parent</span>\n        <span class=\"cm-keyword\">break</span>;\n\n      <span class=\"cm-keyword\">case</span> <span class=\"cm-number\">0x11</span>: <span class=\"cm-comment\">&#47;&#47; Child</span>\n        <span class=\"cm-keyword\">break</span>;\n\n      <span class=\"cm-keyword\">default</span>:\n        <span class=\"cm-variable\">console</span>.<span class=\"cm-property\">log</span>(<span class=\"cm-string-2\">`Unknown type: ${</span><span class=\"cm-variable-2\">type</span>.<span class=\"cm-property\">toString</span>(<span class=\"cm-number\">16</span>)<span class=\"cm-string-2\">}`</span>);\n        <span class=\"cm-keyword\">break</span>;\n    }\n  }\n  <span class=\"cm-variable\">console</span>.<span class=\"cm-property\">log</span>(<span class=\"cm-string-2\">`Value found: ${</span><span class=\"cm-variable-2\">valueFound</span><span class=\"cm-string-2\">}`</span>);\n  <span class=\"cm-keyword\">return</span> <span class=\"cm-variable-2\">values</span>;\n}</span></code></pre></span>\n\t</div>\n</div>"
}