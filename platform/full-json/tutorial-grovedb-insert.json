{
 "metadata": {
  "image": [],
  "title": "",
  "description": ""
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 200
    },
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 400
    }
   ]
  },
  "params": []
 },
 "next": {
  "description": "",
  "pages": []
 },
 "algolia": {
  "recordCount": 11,
  "publishPending": false,
  "updatedAt": "2023-02-08T20:20:34.737Z"
 },
 "title": "Insert",
 "icon": "",
 "updates": [],
 "type": "basic",
 "slug": "tutorial-grovedb-insert",
 "excerpt": "",
 "body": "# Overview\n\nGroveDB uses the `insert()` function to [insert](https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/insert/mod.rs) items into storage. The function takes five arguments as shown below.\n\n``` rust\n/// Insert Element into GroveDB\npub fn insert<'p, P>(\n   &self,\n   // Tree path to the subtree where the key-value should be inserted\n   path: P,\n   // The key\n   key: &'p [u8],\n   // The value\n   element: Element,\n   // Insert options\n   options: Option<InsertOptions>,\n   // Transaction that the insert operation should be included in\n   transaction: TransactionArg,\n)\n```\n\nThis tutorial inserts two key-values into the root tree of the GroveDB instance created in Tutorial 1 (or a new instance if you skipped Tutorial 1). The keys and values of both KVs are strings. Then for the purpose of showing they are there, it uses the `get()` function to retrieve the values and print them to the terminal.\n\n# Code\n\nIn \u201cgrovedb-tutorials\u201d create a new Rust project using `cargo new insert`. Navigate to the new project, add GroveDB to the Cargo.toml file, and paste the following code into the main.rs file. Do `cargo run`.\n\n``` rust\nuse grovedb::GroveDb;\nuse grovedb::Element;\n\nfn main() {\n\n   // Specify a path and open GroveDB at the path as db\n   let path = String::from(\"../storage\");\n   let db = GroveDb::open(path).unwrap();\n\n   // Define key-values for insertion\n   let KEY1 = b\"hello\";\n   let VAL1 = b\"world\";\n   let KEY2 = b\"grovedb\";\n   let VAL2 = b\"rocks\";\n\n   // Insert key-value 1 into the root tree\n   db.insert([], KEY1, Element::Item(VAL1.to_vec(), None), None, None)\n       .unwrap()\n       .expect(\"successful root tree leaf insert\");\n\n   // Insert key-value 2 into the root tree\n   db.insert([], KEY2, Element::Item(VAL2.to_vec(), None), None, None)\n       .unwrap()\n       .expect(\"successful root tree leaf 2 insert\");\n\n   // At this point the Items are fully inserted into the database.\n   // No other steps are required.\n\n   // To show that the Items are there, we will use the get()\n   // function to get them from the RocksDB backing store.\n\n   // Get value 1\n   let result1 = db.get([], KEY1, None).unwrap();\n\n   // Get value 2\n   let result2 = db.get([], KEY2, None).unwrap();\n\n   // Print the values to terminal\n   println!(\"{:?}\", result1);\n   println!(\"{:?}\", result2);\n}\n```\n\nThe terminal should output:\n\n``` text\nOk(item: [hex: 776f726c64, str: world])\nOk(item: [hex: 726f636b73, str: rocks])\n```\n\nThis tells us that at the given keys exist items with the shown hex and str values.\n\nRepo with this example: [https://github.com/thephez/grovedb-tutorials](https://github.com/thephez/grovedb-tutorials)\n\n## Element Enum\n\nIn Tutorial 2, we inserted strings as the values. However, values may be any of the five variants of the `Element` enum:\n\n``` rust\npub enum Element {\n    /// An ordinary value\n    Item(Vec<u8>, Option<ElementFlags>),\n    /// A reference to an object by its path\n    Reference(ReferencePathType, MaxReferenceHop, Option<ElementFlags>),\n    /// A subtree, contains the a prefixed key representing the root of the\n    /// subtree.\n    Tree(Option<Vec<u8>>, Option<ElementFlags>),\n    /// Signed integer value that can be totaled in a sum tree\n    SumItem(SumValue, Option<ElementFlags>),\n    /// Same as Element::Tree but underlying Merk sums value of it's summable\n    /// nodes\n    SumTree(Option<Vec<u8>>, SumValue, Option<ElementFlags>),\n}\n```\n\nFor example, instead of using `let val1 = b\"world\"`, we could have put `let val1 = Element::Tree(None, None)` and then put `val1` in the insert function instead of `Element::Item(val1.to_vec(), None)`.\n\nIn that case, the output would have returned:\n\n``` text\nOk(tree: None)\nOk(item: [hex: 726f636b73, str: rocks])\n```\n\nNote that if you actually want to try this in your existing GroveDB instance, you\u2019ll have to change the keys as well, as you can\u2019t overwrite the existing values.\n\n## Element Functions\n\nInstead of passing `Element::Item()` or some other `Element` enum to the `insert` function, we could also pass one of the functions implemented in `Element`, `new_item()`. Given an item value, the `new_item` function returns `Element::Item(item_value, None)`. It looks like this:\n\n``` rust\nimpl Element {\n    /// Set element to an item with a default flag value\n    pub fn new_item(item_value: Vec<u8>) -> Self {\n        Element::Item(item_value, None)\n    }\n}\n```\n\nAnd would be used like so:\n\n``` rust\n// Insert key-value 1 into the root tree\ndb.insert([], key1, Element::new_item(val1.to_vec()), None, None)\n   .unwrap()\n   .expect(\"successful root tree leaf insert\");\n```\n\nThe `new_item()` function is useful because it allows developers to set a default value for the flags. In our case it\u2019s `None`.\n\nThere are a few other [functions](https://github.com/dashpay/grovedb/blob/master/grovedb/src/element/constructor.rs) implemented in `Element` that can be used similarly. The `Element::empty_tree()` function is quite useful as well.\n\n# Tutorial 3 - Delete\n\nGroveDB uses the `delete()` function to [delete](https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/delete/mod.rs) key-values from storage. It takes four arguments as shown below.\n\n``` rust\n// Delete Element from GroveDB\npub fn delete<'p, P>(\n    &self,\n    // Tree path to where the key is located ([] for root)\n    path: P,\n    // Key to be deleted\n    key: &'p [u8],\n    // Delete options\n    options: Option<DeleteOptions>,\n    // Transaction that the delete operation should be included in\n    transaction: TransactionArg,\n) -> CostResult<(), Error>\n```\n\nThis tutorial assumes the reader has already inserted the two key-values from Tutorial 2, but should be easy to follow anyways. It uses `get()` to check if the values are there first, then deletes them, and checks if they\u2019re there again.\n\nIn \u201cgrovedb-tutorials\u201d create a new Rust project using `cargo new delete`. Navigate to the new project, add GroveDB to the Cargo.toml file, and paste the following code into the main.rs file. Do `cargo run`.\n\n``` rust\nuse grovedb::GroveDb;\n\nfn main() {\n\n   // Specify a path and open GroveDB at the path as db\n   let path = String::from(\"../storage\");\n   let db = GroveDb::open(path).unwrap();\n\n   // Check the key-values are there\n   let KEY1 = b\"hello\";\n   let KEY2 = b\"grovedb\";\n   let result1 = db.get([], KEY1, None).unwrap();\n   let result2 = db.get([], KEY2, None).unwrap();\n   println!(\"Before deleting, we have KEY1: {:?}\", result1);\n   println!(\"Before deleting, we have KEY2: {:?}\", result2);\n\n   // Delete the values\n   db.delete([], KEY1, None, None)\n      .unwrap()\n      .expect(\"successfully deleted key1\");\n   db.delete([], KEY2, None, None)\n      .unwrap()\n      .expect(\"successfully deleted key2\");\n\n   // Check the key-values again\n   let result3 = db.get([], KEY1, None).unwrap();\n   let result4 = db.get([], KEY2, None).unwrap();\n   println!(\"After deleting, we have KEY1: {:?}\", result3);\n   println!(\"After deleting, we have KEY2: {:?}\", result4);\n}\n```\n\nThe terminal should output:\n\n``` text\nBefore deleting, we have KEY1 Ok(item: [hex: 776f726c64, str: world])\nBefore deleting, we have KEY2 Ok(item: [hex: 726f636b73, str: rocks])\nAfter deleting, we have KEY1 Err(PathKeyNotFound(\"key not found in Merk for get: 68656c6c6f\"))\nAfter deleting, we have KEY2 Err(PathKeyNotFound(\"key not found in Merk for get: 67726f76656462\"))\n```\n\n# Tutorial 4 - Query\n\nGroveDB generally uses the `query()` function to perform [queries](https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/get/query.rs) on storage. It takes four arguments as shown below.\n\n```\nimpl GroveDb {\n    /// Returns given path query results\n    pub fn query(\n        &self,\n        path_query: &PathQuery,\n        allow_cache: bool,\n        result_type: QueryResultType,\n        transaction: TransactionArg,\n    ) -> CostResult<(QueryResultElements, u16)\n}\n```\n\n## Explanations\n\nGroveDB queries can be very complex. This section gives explanations of each component of a path query. Deep understanding of each component isn\u2019t necessary to follow and learn from the tutorials, so, if you\u2019d rather learn by doing, feel free to [skip it](#tutorial-4-1-simple-range-query).\n\nA **path query**, which is the first argument of `query()`, has a path and a sized query as parameters. The path points to the highest-level subtree you want to query. You can traverse and recurse into lower-level subtrees within a path query using subqueries, as will be explained later.\n\n``` rust\n/// Path query\npub struct PathQuery {\n    /// Path\n    pub path: Vec<Vec<u8>>,\n    /// Query\n    pub query: SizedQuery,\n}\n```\n\nA **sized query**, which is the second argument of path queries, takes a query, limit, and offset as parameters. The limit is an integer which specifies the maximum number of results to return in the final result set. The offset is an integer which specifies how many items in the front of the raw result set to exclude from the final result set. In other words, the limit specifies a cut-off at the end of the raw result set, and offset specifies a cut-off at the beginning of the raw result set which, after applied, will compose the final result set. As implied, there is an ordering of the raw (and final) result set, which is defined in the other, first, parameter of a sized query: query.\n\n``` rust\n/// Sized query\npub struct SizedQuery {\n    /// Query\n    pub query: Query,\n    /// Limit\n    pub limit: Option<u16>,\n    /// Offset\n    pub offset: Option<u16>,\n}\n```\n\nA **query** takes a vector of query items as its first argument. A **query item** is either a key, set of keys, or a range. Items in these keys or ranges of keys will be added to the raw result set. Subtrees in these keys or ranges of keys are optionally handled with the next two parameters: the default subquery branch and the conditional subquery branch.\n\n``` rust\n/// A `Query` represents one or more keys or ranges of keys, which can be \n/// used to resolve a proof which will include all of the requested values.\npub struct Query {\n    /// Items\n    pub items: Vec<QueryItem>,\n    /// Default subquery branch\n    pub default_subquery_branch: SubqueryBranch,\n    /// Conditional subquery branches\n    pub conditional_subquery_branches: Option<IndexMap<QueryItem, SubqueryBranch>>,\n    /// Left to right?\n    pub left_to_right: bool,\n}\n\n/// A `QueryItem` represents a key or range of keys to be included in a proof.\npub enum QueryItem {\n    Key(Vec<u8>),\n    Range(Range<Vec<u8>>),\n    RangeInclusive(RangeInclusive<Vec<u8>>),\n    RangeFull(RangeFull),\n    RangeFrom(RangeFrom<Vec<u8>>),\n    RangeTo(RangeTo<Vec<u8>>),\n    RangeToInclusive(RangeToInclusive<Vec<u8>>),\n    RangeAfter(RangeFrom<Vec<u8>>),\n    RangeAfterTo(Range<Vec<u8>>),\n    RangeAfterToInclusive(RangeInclusive<Vec<u8>>),\n}\n```\n\nA **default subquery branch** has two parameters: a subquery path and a subquery. The subquery path is a path that is applied to all the subtrees in the result set from the higher-level query we just mentioned. The subquery is a query of the same type as the higher-level query which is applied to the subtrees at the end of the subquery path. The result set of the subquery branch is added to the overall result set. Since subqueries are the same as queries, they can recurse, so you can have subqueries within subqueries. Both subquery path and subquery are optional parameters of a subquery branch. If no subquery path is defined, the subquery applies to all the subtrees in the higher-level query result set. If no subquery is defined, all the elements from the subquery path subtrees are added to the result set.\n\n``` rust\n/// Subquery branch\npub struct SubqueryBranch {\n    /// Subquery path\n    pub subquery_path: Option<Path>,\n    /// Subquery\n    pub subquery: Option<Box<Query>>,\n}\n```\n\nA **conditional subquery branch** is the same as default subquery branches, but takes an additional argument for query items, which again are keys or ranges. The subquery branch is only applied to the subtrees which meet the condition of matching the query items.\n\nFinally, the last parameter of query is left_to_right, which is a boolean that defines the order of the result set. Left to right means lower to higher in terms of integers, or alphabetically in terms of strings.\n\nSee the [documentation](https://github.com/dashpay/grovedb/blob/master/README.md) for more details.\n\n## Get\n\nThe previous tutorials used a function `get()` to retrieve items from storage. _Getting_ only allows for the retrieval of one item, the key must be specified, and cryptographic proofs of _gets_ aren\u2019t supported. Queries, on the other hand, can return many values all at once, the keys don\u2019t need to be provided, and query results _can_ be cryptographically proven.\n\n``` rust\n/// Get an element from the backing store\npub fn get<'p, P>(\n    &self,\n    path: P,\n    key: &'p [u8],\n    transaction: TransactionArg,\n)\n```\n\n## Tutorial 4.1 - Simple Query\n\nThis tutorial populates a GroveDB instance with items within a subtree within a subtree within the root tree. It then constructs and executes a query to retrieve a subset of the items and prints the query result to the terminal.\n\nIn \u201cgrovedb-tutorials\u201d, create a new Rust project using `cargo new simple-query`. Navigate to the new project, add GroveDB to the Cargo.toml file, and paste the following code into the main.rs file. Do `cargo run`.\n\n``` rust\nuse grovedb::GroveDb;\nuse grovedb::Element;\nuse grovedb::{ Query, PathQuery};\n\nconst KEY1: &[u8] = b\"key1\";\nconst KEY2: &[u8] = b\"key2\";\n\nfn main() {\n   \n    // Specify the path where the GroveDB instance exists.\n    let path = String::from(\"../storage\");\n    \n    // Open GroveDB at the path.\n    let db = GroveDb::open(path).unwrap();\n\n    // Populate GroveDB with values. This function is defined below.\n    populate(&db);\n\n    // Define the path to the subtree we want to query.\n    let path = vec![KEY1.to_vec(), KEY2.to_vec()];\n\n    // Instantiate a new query.\n    let mut query = Query::new();\n\n    // Insert a range of keys to the query that we would like returned.\n    // In this case, we are asking for keys 30 through 34.\n    query.insert_range(30_u8.to_be_bytes().to_vec()..35_u8.to_be_bytes().to_vec());\n\n    // Put the query into a new unsized path query.\n    let path_query = PathQuery::new_unsized(path, query.clone());\n\n    // Execute the query and collect the result items in \"elements\".\n    let (elements, _) = db\n        .query_item_value(&path_query, true, None)\n        .unwrap()\n        .expect(\"expected successful get_path_query\");\n\n    // Print result items to terminal.\n    println!(\"{:?}\", elements);\n\n}\n\nfn populate(db: &GroveDb) {\n\n    // Put an empty subtree into the root tree nodes at KEY1.\n    // Call this SUBTREE1.\n    db.insert([], KEY1, Element::empty_tree(), None, None)\n        .unwrap()\n        .expect(\"successful SUBTREE1 insert\");\n\n    // Put an empty subtree into subtree1 at KEY2.\n    // Call this SUBTREE2.\n    db.insert([KEY1], KEY2, Element::empty_tree(), None, None)\n        .unwrap()\n        .expect(\"successful SUBTREE2 insert\");\n\n    // Populate SUBTREE2 with values 0 through 99 under keys 0 through 99.\n    for i in 0u8..100 {\n        let i_vec = (i as u8).to_be_bytes().to_vec();\n        db.insert([KEY1, KEY2], &i_vec, Element::new_item(i_vec.clone()), None, None)\n            .unwrap()\n            .expect(\"successfully inserted values\");\n    }\n}\n```\n\nThe terminal should output:\n\n``` text\n[[30], [31], [32], [33], [34]]\n```\n\n## Tutorial 4.2 - Complex Query\n\nIn \u201cgrovedb-tutorials\u201d, create a new Rust project using `cargo new complex-query`. Navigate to the new project, add GroveDB to the Cargo.toml file, and paste the following code into the main.rs file. Do `cargo run`.\n\n# Tutorial 5 - Proofs\n\nGroveDB generally uses the `prove_query()` function to [generate](https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/proof/generate.rs) query proofs, and the `verify_query()` function to [verify](https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/proof/verify.rs) query proofs. `prove_query()` just takes a path query as an argument and `verify_query()` takes a proof as well as a path query.\n\nThis tutorial assumes the reader has already populated GroveDB with the key-values from Tutorial 4, but should be easy to follow anyways. Note that the first block of code in `main()` is essentially the same as Tutorial 4, but without the `populate()` function. We will generate a proof for the query from Tutorial 4, use it to calculate the root hash, and then compare that root hash to the GroveDB root hash.\n\nIn \u201cgrovedb-tutorials\u201d, create a new Rust project using `cargo new proof`. Navigate to the new project, add GroveDB to the Cargo.toml file, and paste the following code into the main.rs file. Do `cargo run`.\n\n``` rust\nuse grovedb::GroveDb;\nuse grovedb::{ Query, PathQuery };\n\nconst KEY1: &[u8] = b\"key1\";\nconst KEY2: &[u8] = b\"key2\";\n\nfn main() {\n\n    // Specify the path to the previously created GroveDB instance\n    let path = String::from(\"../storage\");\n    // Open GroveDB as db\n    let db = GroveDb::open(path).unwrap();\n    // Define the path to the subtree we want to query.\n    let path = vec![KEY1.to_vec(), KEY2.to_vec()];\n    // Instantiate a new query.\n    let mut query = Query::new();\n    // Insert a range of keys to the query that we would like returned.\n    query.insert_range(30_u8.to_be_bytes().to_vec()..35_u8.to_be_bytes().to_vec());\n    // Put the query into a new unsized path query.\n    let path_query = PathQuery::new_unsized(path, query.clone());\n    // Execute the query and collect the result items in \"elements\".\n    let (_elements, _) = db\n        .query_item_value(&path_query, true, None)\n        .unwrap()\n        .expect(\"expected successful get_path_query\");\n\n    // Generate proof.\n    let proof = db.prove_query(&path_query).unwrap().unwrap();\n\n    // Get hash from query proof and print to terminal along with GroveDB root hash.\n    let (hash, _result_set) = GroveDb::verify_query(&proof, &path_query).unwrap();\n\n    // See if the query proof hash matches the GroveDB root hash\n    println!(\"Does the hash generated from the query proof match the GroveDB root hash?\");\n    if hash == db.root_hash(None).unwrap().unwrap() {\n        println!(\"Yes\");\n    } else { println!(\"No\"); };\n}\n```\n\nThe terminal should output:\n\n``` text\nDoes the hash generated from the query proof match the GroveDB root hash?\nYes\n```\n\nNow you know that your query results are complete, correct, and fresh.",
 "order": 999,
 "isReference": false,
 "deprecated": false,
 "hidden": true,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "previousSlug": "",
 "slugUpdatedAt": "2023-02-08T19:42:44.337Z",
 "revision": 5,
 "_id": "63e402ecf5ab0b0101eba992",
 "user": "5b8400d7185d5e00036dcc3b",
 "project": "5bda01cad172e200499a20a9",
 "parentDoc": "63e3fe3af08aa20020c707e5",
 "category": "62b226d1fcc32e002300c509",
 "createdAt": "2023-02-08T20:15:40.626Z",
 "updatedAt": "2023-02-08T20:20:34.286Z",
 "version": "62b226d1fcc32e002300c574",
 "__v": 0,
 "isApi": false,
 "id": "63e402ecf5ab0b0101eba992",
 "body_html": "<div class=\"magic-block-textarea\"><h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-overview\"></div>Overview<a class=\"fa fa-anchor\" href=\"#section-overview\"></a></h1>\n<p>GroveDB uses the <code>insert()</code> function to <a href=\"https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/insert/mod.rs\">insert</a> items into storage. The function takes five arguments as shown below.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; Insert Element into GroveDB</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">insert</span><span class=\"cm-operator\">&lt;</span>'<span class=\"cm-variable\">p</span>, <span class=\"cm-variable\">P</span><span class=\"cm-operator\">&gt;</span>(\n   &amp;<span class=\"cm-keyword\">self</span>,\n   <span class=\"cm-comment\">&#47;&#47; Tree path to the subtree where the key-value should be inserted</span>\n   <span class=\"cm-variable\">path</span>: <span class=\"cm-variable\">P</span>,\n   <span class=\"cm-comment\">&#47;&#47; The key</span>\n   <span class=\"cm-variable\">key</span>: &amp;'<span class=\"cm-variable\">p</span> [<span class=\"cm-atom\">u8</span>],\n   <span class=\"cm-comment\">&#47;&#47; The value</span>\n   <span class=\"cm-variable\">element</span>: <span class=\"cm-variable\">Element</span>,\n   <span class=\"cm-comment\">&#47;&#47; Insert options</span>\n   <span class=\"cm-variable\">options</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">InsertOptions</span><span class=\"cm-operator\">&gt;</span>,\n   <span class=\"cm-comment\">&#47;&#47; Transaction that the insert operation should be included in</span>\n   <span class=\"cm-variable\">transaction</span>: <span class=\"cm-variable\">TransactionArg</span>,\n)</span>\n</code></pre>\n<p>This tutorial inserts two key-values into the root tree of the GroveDB instance created in Tutorial 1 (or a new instance if you skipped Tutorial 1). The keys and values of both KVs are strings. Then for the purpose of showing they are there, it uses the <code>get()</code> function to retrieve the values and print them to the terminal.</p>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-code\"></div>Code<a class=\"fa fa-anchor\" href=\"#section-code\"></a></h1>\n<p>In \u201cgrovedb-tutorials\u201d create a new Rust project using <code>cargo new insert</code>. Navigate to the new project, add GroveDB to the Cargo.toml file, and paste the following code into the main.rs file. Do <code>cargo run</code>.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">GroveDb</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">Element</span>;\n\n<span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">main</span>() {\n\n   <span class=\"cm-comment\">&#47;&#47; Specify a path and open GroveDB at the path as db</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">String</span>::<span class=\"cm-variable\">from</span>(<span class=\"cm-string\">\"..&#47;storage\"</span>);\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">db</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">GroveDb</span>::<span class=\"cm-variable\">open</span>(<span class=\"cm-variable\">path</span>).<span class=\"cm-variable\">unwrap</span>();\n\n   <span class=\"cm-comment\">&#47;&#47; Define key-values for insertion</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">KEY1</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"hello\"</span>;\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">VAL1</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"world\"</span>;\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">KEY2</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"grovedb\"</span>;\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">VAL2</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"rocks\"</span>;\n\n   <span class=\"cm-comment\">&#47;&#47; Insert key-value 1 into the root tree</span>\n   <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([], <span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">Item</span>(<span class=\"cm-variable\">VAL1</span>.<span class=\"cm-variable\">to_vec</span>(), <span class=\"cm-builtin\">None</span>), <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n       .<span class=\"cm-variable\">unwrap</span>()\n       .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful root tree leaf insert\"</span>);\n\n   <span class=\"cm-comment\">&#47;&#47; Insert key-value 2 into the root tree</span>\n   <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([], <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">Item</span>(<span class=\"cm-variable\">VAL2</span>.<span class=\"cm-variable\">to_vec</span>(), <span class=\"cm-builtin\">None</span>), <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n       .<span class=\"cm-variable\">unwrap</span>()\n       .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful root tree leaf 2 insert\"</span>);\n\n   <span class=\"cm-comment\">&#47;&#47; At this point the Items are fully inserted into the database.</span>\n   <span class=\"cm-comment\">&#47;&#47; No other steps are required.</span>\n\n   <span class=\"cm-comment\">&#47;&#47; To show that the Items are there, we will use the get()</span>\n   <span class=\"cm-comment\">&#47;&#47; function to get them from the RocksDB backing store.</span>\n\n   <span class=\"cm-comment\">&#47;&#47; Get value 1</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">result1</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">get</span>([], <span class=\"cm-variable\">KEY1</span>, <span class=\"cm-builtin\">None</span>).<span class=\"cm-variable\">unwrap</span>();\n\n   <span class=\"cm-comment\">&#47;&#47; Get value 2</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">result2</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">get</span>([], <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-builtin\">None</span>).<span class=\"cm-variable\">unwrap</span>();\n\n   <span class=\"cm-comment\">&#47;&#47; Print the values to terminal</span>\n   <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"{:?}\"</span>, <span class=\"cm-variable\">result1</span>);\n   <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"{:?}\"</span>, <span class=\"cm-variable\">result2</span>);\n}</span>\n</code></pre>\n<p>The terminal should output:</p>\n<pre><code class=\"lang-text\">Ok(item: [hex: 776f726c64, str: world])\nOk(item: [hex: 726f636b73, str: rocks])\n</code></pre>\n<p>This tells us that at the given keys exist items with the shown hex and str values.</p>\n<p>Repo with this example: <a href=\"https://github.com/thephez/grovedb-tutorials\">https://github.com/thephez/grovedb-tutorials</a></p>\n<h2 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-element-enum\"></div>Element Enum<a class=\"fa fa-anchor\" href=\"#section-element-enum\"></a></h2>\n<p>In Tutorial 2, we inserted strings as the values. However, values may be any of the five variants of the <code>Element</code> enum:</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">enum</span> <span class=\"cm-def\">Element</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; An ordinary value</span>\n    <span class=\"cm-variable\">Item</span>(<span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;</span>, <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">ElementFlags</span><span class=\"cm-operator\">&gt;</span>),\n    <span class=\"cm-comment\">&#47;&#47;&#47; A reference to an object by its path</span>\n    <span class=\"cm-variable\">Reference</span>(<span class=\"cm-variable\">ReferencePathType</span>, <span class=\"cm-variable\">MaxReferenceHop</span>, <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">ElementFlags</span><span class=\"cm-operator\">&gt;</span>),\n    <span class=\"cm-comment\">&#47;&#47;&#47; A subtree, contains the a prefixed key representing the root of the</span>\n    <span class=\"cm-comment\">&#47;&#47;&#47; subtree.</span>\n    <span class=\"cm-variable\">Tree</span>(<span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>, <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">ElementFlags</span><span class=\"cm-operator\">&gt;</span>),\n    <span class=\"cm-comment\">&#47;&#47;&#47; Signed integer value that can be totaled in a sum tree</span>\n    <span class=\"cm-variable\">SumItem</span>(<span class=\"cm-variable\">SumValue</span>, <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">ElementFlags</span><span class=\"cm-operator\">&gt;</span>),\n    <span class=\"cm-comment\">&#47;&#47;&#47; Same as Element::Tree but underlying Merk sums value of it's summable</span>\n    <span class=\"cm-comment\">&#47;&#47;&#47; nodes</span>\n    <span class=\"cm-variable\">SumTree</span>(<span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>, <span class=\"cm-variable\">SumValue</span>, <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">ElementFlags</span><span class=\"cm-operator\">&gt;</span>),\n}</span>\n</code></pre>\n<p>For example, instead of using <code>let val1 = b&quot;world&quot;</code>, we could have put <code>let val1 = Element::Tree(None, None)</code> and then put <code>val1</code> in the insert function instead of <code>Element::Item(val1.to_vec(), None)</code>.</p>\n<p>In that case, the output would have returned:</p>\n<pre><code class=\"lang-text\">Ok(tree: None)\nOk(item: [hex: 726f636b73, str: rocks])\n</code></pre>\n<p>Note that if you actually want to try this in your existing GroveDB instance, you\u2019ll have to change the keys as well, as you can\u2019t overwrite the existing values.</p>\n<h2 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-element-functions\"></div>Element Functions<a class=\"fa fa-anchor\" href=\"#section-element-functions\"></a></h2>\n<p>Instead of passing <code>Element::Item()</code> or some other <code>Element</code> enum to the <code>insert</code> function, we could also pass one of the functions implemented in <code>Element</code>, <code>new_item()</code>. Given an item value, the <code>new_item</code> function returns <code>Element::Item(item_value, None)</code>. It looks like this:</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">impl</span> <span class=\"cm-variable\">Element</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; Set element to an item with a default flag value</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">new_item</span>(<span class=\"cm-variable\">item_value</span>: <span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;</span>) <span class=\"cm-operator\">-&gt;</span> <span class=\"cm-atom\">Self</span> {\n        <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">Item</span>(<span class=\"cm-variable\">item_value</span>, <span class=\"cm-builtin\">None</span>)\n    }\n}</span>\n</code></pre>\n<p>And would be used like so:</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47; Insert key-value 1 into the root tree</span>\n<span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([], <span class=\"cm-variable\">key1</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">new_item</span>(<span class=\"cm-variable\">val1</span>.<span class=\"cm-variable\">to_vec</span>()), <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n   .<span class=\"cm-variable\">unwrap</span>()\n   .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful root tree leaf insert\"</span>);</span>\n</code></pre>\n<p>The <code>new_item()</code> function is useful because it allows developers to set a default value for the flags. In our case it\u2019s <code>None</code>.</p>\n<p>There are a few other <a href=\"https://github.com/dashpay/grovedb/blob/master/grovedb/src/element/constructor.rs\">functions</a> implemented in <code>Element</code> that can be used similarly. The <code>Element::empty_tree()</code> function is quite useful as well.</p>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-tutorial-3-delete\"></div>Tutorial 3 - Delete<a class=\"fa fa-anchor\" href=\"#section-tutorial-3-delete\"></a></h1>\n<p>GroveDB uses the <code>delete()</code> function to <a href=\"https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/delete/mod.rs\">delete</a> key-values from storage. It takes four arguments as shown below.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47; Delete Element from GroveDB</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">delete</span><span class=\"cm-operator\">&lt;</span>'<span class=\"cm-variable\">p</span>, <span class=\"cm-variable\">P</span><span class=\"cm-operator\">&gt;</span>(\n    &amp;<span class=\"cm-keyword\">self</span>,\n    <span class=\"cm-comment\">&#47;&#47; Tree path to where the key is located ([] for root)</span>\n    <span class=\"cm-variable\">path</span>: <span class=\"cm-variable\">P</span>,\n    <span class=\"cm-comment\">&#47;&#47; Key to be deleted</span>\n    <span class=\"cm-variable\">key</span>: &amp;'<span class=\"cm-variable\">p</span> [<span class=\"cm-atom\">u8</span>],\n    <span class=\"cm-comment\">&#47;&#47; Delete options</span>\n    <span class=\"cm-variable\">options</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">DeleteOptions</span><span class=\"cm-operator\">&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47; Transaction that the delete operation should be included in</span>\n    <span class=\"cm-variable\">transaction</span>: <span class=\"cm-variable\">TransactionArg</span>,\n) <span class=\"cm-operator\">-&gt;</span> <span class=\"cm-variable\">CostResult</span><span class=\"cm-operator\">&lt;</span>(), <span class=\"cm-variable\">Error</span><span class=\"cm-operator\">&gt;</span></span>\n</code></pre>\n<p>This tutorial assumes the reader has already inserted the two key-values from Tutorial 2, but should be easy to follow anyways. It uses <code>get()</code> to check if the values are there first, then deletes them, and checks if they\u2019re there again.</p>\n<p>In \u201cgrovedb-tutorials\u201d create a new Rust project using <code>cargo new delete</code>. Navigate to the new project, add GroveDB to the Cargo.toml file, and paste the following code into the main.rs file. Do <code>cargo run</code>.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">GroveDb</span>;\n\n<span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">main</span>() {\n\n   <span class=\"cm-comment\">&#47;&#47; Specify a path and open GroveDB at the path as db</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">String</span>::<span class=\"cm-variable\">from</span>(<span class=\"cm-string\">\"..&#47;storage\"</span>);\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">db</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">GroveDb</span>::<span class=\"cm-variable\">open</span>(<span class=\"cm-variable\">path</span>).<span class=\"cm-variable\">unwrap</span>();\n\n   <span class=\"cm-comment\">&#47;&#47; Check the key-values are there</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">KEY1</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"hello\"</span>;\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">KEY2</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"grovedb\"</span>;\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">result1</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">get</span>([], <span class=\"cm-variable\">KEY1</span>, <span class=\"cm-builtin\">None</span>).<span class=\"cm-variable\">unwrap</span>();\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">result2</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">get</span>([], <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-builtin\">None</span>).<span class=\"cm-variable\">unwrap</span>();\n   <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"Before deleting, we have KEY1: {:?}\"</span>, <span class=\"cm-variable\">result1</span>);\n   <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"Before deleting, we have KEY2: {:?}\"</span>, <span class=\"cm-variable\">result2</span>);\n\n   <span class=\"cm-comment\">&#47;&#47; Delete the values</span>\n   <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">delete</span>([], <span class=\"cm-variable\">KEY1</span>, <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n      .<span class=\"cm-variable\">unwrap</span>()\n      .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successfully deleted key1\"</span>);\n   <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">delete</span>([], <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n      .<span class=\"cm-variable\">unwrap</span>()\n      .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successfully deleted key2\"</span>);\n\n   <span class=\"cm-comment\">&#47;&#47; Check the key-values again</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">result3</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">get</span>([], <span class=\"cm-variable\">KEY1</span>, <span class=\"cm-builtin\">None</span>).<span class=\"cm-variable\">unwrap</span>();\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">result4</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">get</span>([], <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-builtin\">None</span>).<span class=\"cm-variable\">unwrap</span>();\n   <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"After deleting, we have KEY1: {:?}\"</span>, <span class=\"cm-variable\">result3</span>);\n   <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"After deleting, we have KEY2: {:?}\"</span>, <span class=\"cm-variable\">result4</span>);\n}</span>\n</code></pre>\n<p>The terminal should output:</p>\n<pre><code class=\"lang-text\">Before deleting, we have KEY1 Ok(item: [hex: 776f726c64, str: world])\nBefore deleting, we have KEY2 Ok(item: [hex: 726f636b73, str: rocks])\nAfter deleting, we have KEY1 Err(PathKeyNotFound(&quot;key not found in Merk for get: 68656c6c6f&quot;))\nAfter deleting, we have KEY2 Err(PathKeyNotFound(&quot;key not found in Merk for get: 67726f76656462&quot;))\n</code></pre>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-tutorial-4-query\"></div>Tutorial 4 - Query<a class=\"fa fa-anchor\" href=\"#section-tutorial-4-query\"></a></h1>\n<p>GroveDB generally uses the <code>query()</code> function to perform <a href=\"https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/get/query.rs\">queries</a> on storage. It takes four arguments as shown below.</p>\n<pre><code>impl GroveDb {\n    /// Returns given path query results\n    pub fn query(\n        &amp;self,\n        path_query: &amp;PathQuery,\n        allow_cache: bool,\n        result_type: QueryResultType,\n        transaction: TransactionArg,\n    ) -&gt; CostResult&lt;(QueryResultElements, u16)\n}\n</code></pre><h2 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-explanations\"></div>Explanations<a class=\"fa fa-anchor\" href=\"#section-explanations\"></a></h2>\n<p>GroveDB queries can be very complex. This section gives explanations of each component of a path query. Deep understanding of each component isn\u2019t necessary to follow and learn from the tutorials, so, if you\u2019d rather learn by doing, feel free to <a href=\"#tutorial-4-1-simple-range-query\">skip it</a>.</p>\n<p>A <strong>path query</strong>, which is the first argument of <code>query()</code>, has a path and a sized query as parameters. The path points to the highest-level subtree you want to query. You can traverse and recurse into lower-level subtrees within a path query using subqueries, as will be explained later.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; Path query</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">struct</span> <span class=\"cm-def\">PathQuery</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; Path</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">path</span>: <span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Query</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">query</span>: <span class=\"cm-variable\">SizedQuery</span>,\n}</span>\n</code></pre>\n<p>A <strong>sized query</strong>, which is the second argument of path queries, takes a query, limit, and offset as parameters. The limit is an integer which specifies the maximum number of results to return in the final result set. The offset is an integer which specifies how many items in the front of the raw result set to exclude from the final result set. In other words, the limit specifies a cut-off at the end of the raw result set, and offset specifies a cut-off at the beginning of the raw result set which, after applied, will compose the final result set. As implied, there is an ordering of the raw (and final) result set, which is defined in the other, first, parameter of a sized query: query.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; Sized query</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">struct</span> <span class=\"cm-def\">SizedQuery</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; Query</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">query</span>: <span class=\"cm-variable\">Query</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Limit</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">limit</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u16</span><span class=\"cm-operator\">&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Offset</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">offset</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u16</span><span class=\"cm-operator\">&gt;</span>,\n}</span>\n</code></pre>\n<p>A <strong>query</strong> takes a vector of query items as its first argument. A <strong>query item</strong> is either a key, set of keys, or a range. Items in these keys or ranges of keys will be added to the raw result set. Subtrees in these keys or ranges of keys are optionally handled with the next two parameters: the default subquery branch and the conditional subquery branch.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; A `Query` represents one or more keys or ranges of keys, which can be </span>\n<span class=\"cm-comment\">&#47;&#47;&#47; used to resolve a proof which will include all of the requested values.</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">struct</span> <span class=\"cm-def\">Query</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; Items</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">items</span>: <span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">QueryItem</span><span class=\"cm-operator\">&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Default subquery branch</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">default_subquery_branch</span>: <span class=\"cm-variable\">SubqueryBranch</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Conditional subquery branches</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">conditional_subquery_branches</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">IndexMap</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">QueryItem</span>, <span class=\"cm-variable\">SubqueryBranch</span><span class=\"cm-operator\">&gt;&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Left to right?</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">left_to_right</span>: <span class=\"cm-atom\">bool</span>,\n}\n\n<span class=\"cm-comment\">&#47;&#47;&#47; A `QueryItem` represents a key or range of keys to be included in a proof.</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">enum</span> <span class=\"cm-def\">QueryItem</span> {\n    <span class=\"cm-variable\">Key</span>(<span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;</span>),\n    <span class=\"cm-variable\">Range</span>(<span class=\"cm-variable\">Range</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeInclusive</span>(<span class=\"cm-variable\">RangeInclusive</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeFull</span>(<span class=\"cm-variable\">RangeFull</span>),\n    <span class=\"cm-variable\">RangeFrom</span>(<span class=\"cm-variable\">RangeFrom</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeTo</span>(<span class=\"cm-variable\">RangeTo</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeToInclusive</span>(<span class=\"cm-variable\">RangeToInclusive</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeAfter</span>(<span class=\"cm-variable\">RangeFrom</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeAfterTo</span>(<span class=\"cm-variable\">Range</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeAfterToInclusive</span>(<span class=\"cm-variable\">RangeInclusive</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n}</span>\n</code></pre>\n<p>A <strong>default subquery branch</strong> has two parameters: a subquery path and a subquery. The subquery path is a path that is applied to all the subtrees in the result set from the higher-level query we just mentioned. The subquery is a query of the same type as the higher-level query which is applied to the subtrees at the end of the subquery path. The result set of the subquery branch is added to the overall result set. Since subqueries are the same as queries, they can recurse, so you can have subqueries within subqueries. Both subquery path and subquery are optional parameters of a subquery branch. If no subquery path is defined, the subquery applies to all the subtrees in the higher-level query result set. If no subquery is defined, all the elements from the subquery path subtrees are added to the result set.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; Subquery branch</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">struct</span> <span class=\"cm-def\">SubqueryBranch</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; Subquery path</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">subquery_path</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Path</span><span class=\"cm-operator\">&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Subquery</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">subquery</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Box</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Query</span><span class=\"cm-operator\">&gt;&gt;</span>,\n}</span>\n</code></pre>\n<p>A <strong>conditional subquery branch</strong> is the same as default subquery branches, but takes an additional argument for query items, which again are keys or ranges. The subquery branch is only applied to the subtrees which meet the condition of matching the query items.</p>\n<p>Finally, the last parameter of query is left_to_right, which is a boolean that defines the order of the result set. Left to right means lower to higher in terms of integers, or alphabetically in terms of strings.</p>\n<p>See the <a href=\"https://github.com/dashpay/grovedb/blob/master/README.md\">documentation</a> for more details.</p>\n<h2 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-get\"></div>Get<a class=\"fa fa-anchor\" href=\"#section-get\"></a></h2>\n<p>The previous tutorials used a function <code>get()</code> to retrieve items from storage. <em>Getting</em> only allows for the retrieval of one item, the key must be specified, and cryptographic proofs of <em>gets</em> aren\u2019t supported. Queries, on the other hand, can return many values all at once, the keys don\u2019t need to be provided, and query results <em>can</em> be cryptographically proven.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; Get an element from the backing store</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">get</span><span class=\"cm-operator\">&lt;</span>'<span class=\"cm-variable\">p</span>, <span class=\"cm-variable\">P</span><span class=\"cm-operator\">&gt;</span>(\n    &amp;<span class=\"cm-keyword\">self</span>,\n    <span class=\"cm-variable\">path</span>: <span class=\"cm-variable\">P</span>,\n    <span class=\"cm-variable\">key</span>: &amp;'<span class=\"cm-variable\">p</span> [<span class=\"cm-atom\">u8</span>],\n    <span class=\"cm-variable\">transaction</span>: <span class=\"cm-variable\">TransactionArg</span>,\n)</span>\n</code></pre>\n<h2 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-tutorial-4-1-simple-query\"></div>Tutorial 4.1 - Simple Query<a class=\"fa fa-anchor\" href=\"#section-tutorial-4-1-simple-query\"></a></h2>\n<p>This tutorial populates a GroveDB instance with items within a subtree within a subtree within the root tree. It then constructs and executes a query to retrieve a subset of the items and prints the query result to the terminal.</p>\n<p>In \u201cgrovedb-tutorials\u201d, create a new Rust project using <code>cargo new simple-query</code>. Navigate to the new project, add GroveDB to the Cargo.toml file, and paste the following code into the main.rs file. Do <code>cargo run</code>.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">GroveDb</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">Element</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::{ <span class=\"cm-variable\">Query</span>, <span class=\"cm-variable\">PathQuery</span>};\n\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">KEY1</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"key1\"</span>;\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">KEY2</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"key2\"</span>;\n\n<span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">main</span>() {\n\n    <span class=\"cm-comment\">&#47;&#47; Specify the path where the GroveDB instance exists.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">String</span>::<span class=\"cm-variable\">from</span>(<span class=\"cm-string\">\"..&#47;storage\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Open GroveDB at the path.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">db</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">GroveDb</span>::<span class=\"cm-variable\">open</span>(<span class=\"cm-variable\">path</span>).<span class=\"cm-variable\">unwrap</span>();\n\n    <span class=\"cm-comment\">&#47;&#47; Populate GroveDB with values. This function is defined below.</span>\n    <span class=\"cm-variable\">populate</span>(&amp;<span class=\"cm-variable\">db</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Define the path to the subtree we want to query.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-3\">vec!</span>[<span class=\"cm-variable\">KEY1</span>.<span class=\"cm-variable\">to_vec</span>(), <span class=\"cm-variable\">KEY2</span>.<span class=\"cm-variable\">to_vec</span>()];\n\n    <span class=\"cm-comment\">&#47;&#47; Instantiate a new query.</span>\n    <span class=\"cm-keyword\">let mut</span> <span class=\"cm-def\">query</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">Query</span>::<span class=\"cm-variable\">new</span>();\n\n    <span class=\"cm-comment\">&#47;&#47; Insert a range of keys to the query that we would like returned.</span>\n    <span class=\"cm-comment\">&#47;&#47; In this case, we are asking for keys 30 through 34.</span>\n    <span class=\"cm-variable\">query</span>.<span class=\"cm-variable\">insert_range</span>(<span class=\"cm-number\">30_u8</span>.<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>()..<span class=\"cm-number\">35_u8</span>.<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>());\n\n    <span class=\"cm-comment\">&#47;&#47; Put the query into a new unsized path query.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path_query</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">PathQuery</span>::<span class=\"cm-variable\">new_unsized</span>(<span class=\"cm-variable\">path</span>, <span class=\"cm-variable\">query</span>.<span class=\"cm-variable\">clone</span>());\n\n    <span class=\"cm-comment\">&#47;&#47; Execute the query and collect the result items in \"elements\".</span>\n    <span class=\"cm-variable\">let</span> (<span class=\"cm-variable\">elements</span>, <span class=\"cm-variable\">_</span>) <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>\n        .<span class=\"cm-variable\">query_item_value</span>(&amp;<span class=\"cm-variable\">path_query</span>, <span class=\"cm-builtin\">true</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"expected successful get_path_query\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Print result items to terminal.</span>\n    <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"{:?}\"</span>, <span class=\"cm-variable\">elements</span>);\n\n}\n\n<span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">populate</span>(<span class=\"cm-variable\">db</span>: &amp;<span class=\"cm-variable\">GroveDb</span>) {\n\n    <span class=\"cm-comment\">&#47;&#47; Put an empty subtree into the root tree nodes at KEY1.</span>\n    <span class=\"cm-comment\">&#47;&#47; Call this SUBTREE1.</span>\n    <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([], <span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">empty_tree</span>(), <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful SUBTREE1 insert\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Put an empty subtree into subtree1 at KEY2.</span>\n    <span class=\"cm-comment\">&#47;&#47; Call this SUBTREE2.</span>\n    <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([<span class=\"cm-variable\">KEY1</span>], <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">empty_tree</span>(), <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful SUBTREE2 insert\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Populate SUBTREE2 with values 0 through 99 under keys 0 through 99.</span>\n    <span class=\"cm-keyword\">for</span> <span class=\"cm-variable\">i</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-number\">0u8</span>..<span class=\"cm-number\">100</span> {\n        <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">i_vec</span> <span class=\"cm-operator\">=</span> (<span class=\"cm-variable\">i</span> <span class=\"cm-keyword\">as</span> <span class=\"cm-atom\">u8</span>).<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>();\n        <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([<span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">KEY2</span>], &amp;<span class=\"cm-variable\">i_vec</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">new_item</span>(<span class=\"cm-variable\">i_vec</span>.<span class=\"cm-variable\">clone</span>()), <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n            .<span class=\"cm-variable\">unwrap</span>()\n            .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successfully inserted values\"</span>);\n    }\n}</span>\n</code></pre>\n<p>The terminal should output:</p>\n<pre><code class=\"lang-text\">[[30], [31], [32], [33], [34]]\n</code></pre>\n<h2 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-tutorial-4-2-complex-query\"></div>Tutorial 4.2 - Complex Query<a class=\"fa fa-anchor\" href=\"#section-tutorial-4-2-complex-query\"></a></h2>\n<p>In \u201cgrovedb-tutorials\u201d, create a new Rust project using <code>cargo new complex-query</code>. Navigate to the new project, add GroveDB to the Cargo.toml file, and paste the following code into the main.rs file. Do <code>cargo run</code>.</p>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-tutorial-5-proofs\"></div>Tutorial 5 - Proofs<a class=\"fa fa-anchor\" href=\"#section-tutorial-5-proofs\"></a></h1>\n<p>GroveDB generally uses the <code>prove_query()</code> function to <a href=\"https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/proof/generate.rs\">generate</a> query proofs, and the <code>verify_query()</code> function to <a href=\"https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/proof/verify.rs\">verify</a> query proofs. <code>prove_query()</code> just takes a path query as an argument and <code>verify_query()</code> takes a proof as well as a path query.</p>\n<p>This tutorial assumes the reader has already populated GroveDB with the key-values from Tutorial 4, but should be easy to follow anyways. Note that the first block of code in <code>main()</code> is essentially the same as Tutorial 4, but without the <code>populate()</code> function. We will generate a proof for the query from Tutorial 4, use it to calculate the root hash, and then compare that root hash to the GroveDB root hash.</p>\n<p>In \u201cgrovedb-tutorials\u201d, create a new Rust project using <code>cargo new proof</code>. Navigate to the new project, add GroveDB to the Cargo.toml file, and paste the following code into the main.rs file. Do <code>cargo run</code>.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">GroveDb</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::{ <span class=\"cm-variable\">Query</span>, <span class=\"cm-variable\">PathQuery</span> };\n\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">KEY1</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"key1\"</span>;\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">KEY2</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"key2\"</span>;\n\n<span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">main</span>() {\n\n    <span class=\"cm-comment\">&#47;&#47; Specify the path to the previously created GroveDB instance</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">String</span>::<span class=\"cm-variable\">from</span>(<span class=\"cm-string\">\"..&#47;storage\"</span>);\n    <span class=\"cm-comment\">&#47;&#47; Open GroveDB as db</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">db</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">GroveDb</span>::<span class=\"cm-variable\">open</span>(<span class=\"cm-variable\">path</span>).<span class=\"cm-variable\">unwrap</span>();\n    <span class=\"cm-comment\">&#47;&#47; Define the path to the subtree we want to query.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-3\">vec!</span>[<span class=\"cm-variable\">KEY1</span>.<span class=\"cm-variable\">to_vec</span>(), <span class=\"cm-variable\">KEY2</span>.<span class=\"cm-variable\">to_vec</span>()];\n    <span class=\"cm-comment\">&#47;&#47; Instantiate a new query.</span>\n    <span class=\"cm-keyword\">let mut</span> <span class=\"cm-def\">query</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">Query</span>::<span class=\"cm-variable\">new</span>();\n    <span class=\"cm-comment\">&#47;&#47; Insert a range of keys to the query that we would like returned.</span>\n    <span class=\"cm-variable\">query</span>.<span class=\"cm-variable\">insert_range</span>(<span class=\"cm-number\">30_u8</span>.<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>()..<span class=\"cm-number\">35_u8</span>.<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>());\n    <span class=\"cm-comment\">&#47;&#47; Put the query into a new unsized path query.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path_query</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">PathQuery</span>::<span class=\"cm-variable\">new_unsized</span>(<span class=\"cm-variable\">path</span>, <span class=\"cm-variable\">query</span>.<span class=\"cm-variable\">clone</span>());\n    <span class=\"cm-comment\">&#47;&#47; Execute the query and collect the result items in \"elements\".</span>\n    <span class=\"cm-variable\">let</span> (<span class=\"cm-variable\">_elements</span>, <span class=\"cm-variable\">_</span>) <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>\n        .<span class=\"cm-variable\">query_item_value</span>(&amp;<span class=\"cm-variable\">path_query</span>, <span class=\"cm-builtin\">true</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"expected successful get_path_query\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Generate proof.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">proof</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">prove_query</span>(&amp;<span class=\"cm-variable\">path_query</span>).<span class=\"cm-variable\">unwrap</span>().<span class=\"cm-variable\">unwrap</span>();\n\n    <span class=\"cm-comment\">&#47;&#47; Get hash from query proof and print to terminal along with GroveDB root hash.</span>\n    <span class=\"cm-variable\">let</span> (<span class=\"cm-variable\">hash</span>, <span class=\"cm-variable\">_result_set</span>) <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">GroveDb</span>::<span class=\"cm-variable\">verify_query</span>(&amp;<span class=\"cm-variable\">proof</span>, &amp;<span class=\"cm-variable\">path_query</span>).<span class=\"cm-variable\">unwrap</span>();\n\n    <span class=\"cm-comment\">&#47;&#47; See if the query proof hash matches the GroveDB root hash</span>\n    <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"Does the hash generated from the query proof match the GroveDB root hash?\"</span>);\n    <span class=\"cm-keyword\">if</span> <span class=\"cm-variable\">hash</span> <span class=\"cm-operator\">==</span> <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">root_hash</span>(<span class=\"cm-builtin\">None</span>).<span class=\"cm-variable\">unwrap</span>().<span class=\"cm-variable\">unwrap</span>() {\n        <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"Yes\"</span>);\n    } <span class=\"cm-keyword\">else</span> { <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"No\"</span>); };\n}</span>\n</code></pre>\n<p>The terminal should output:</p>\n<pre><code class=\"lang-text\">Does the hash generated from the query proof match the GroveDB root hash?\nYes\n</code></pre>\n<p>Now you know that your query results are complete, correct, and fresh.</p>\n\n</div>"
}