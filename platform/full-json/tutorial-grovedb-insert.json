{
 "metadata": {
  "image": [],
  "title": "",
  "description": "",
  "keywords": "",
  "robots": "index"
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 200
    },
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 400
    }
   ]
  },
  "params": []
 },
 "next": {
  "description": "",
  "pages": []
 },
 "algolia": {
  "recordCount": 3,
  "publishPending": false,
  "translationFailure": false,
  "updatedAt": "2023-09-06T16:36:48.453Z"
 },
 "title": "Insert",
 "icon": "",
 "updates": [],
 "type": "basic",
 "slug": "tutorial-grovedb-insert",
 "excerpt": "",
 "body": "# Tutorial\n\nGroveDB uses the `insert()` function to [insert](https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/insert/mod.rs) items into storage. Insert will also overwrite values unless the value is a tree. The function takes five arguments as shown below.\n\n``` rust\n/// Insert Element into GroveDB\npub fn insert<'p, P>(\n   &self,\n   // Tree path to the subtree where the key-value should be inserted\n   path: P,\n   // The key\n   key: &'p [u8],\n   // The value\n   element: Element,\n   // Insert options\n   options: Option<InsertOptions>,\n   // Transaction that the insert operation should be included in\n   transaction: TransactionArg,\n)\n```\n\nThis tutorial inserts two key-values into the root tree of the GroveDB instance created in Open Tutorial (or a new instance if you skipped Open Tutorial). The keys and values of both KVs are strings. Then for the purpose of showing they are there, it uses the `get()` function to retrieve the values and print them to the terminal.\n\nThe following code can be run with ```cargo run --bin insert```.\n\n``` rust\nuse grovedb::GroveDb;\nuse grovedb::Element;\n\nfn main() {\n\n   // Specify a path and open GroveDB at the path as db\n   let path = String::from(\"../storage\");\n   let db = GroveDb::open(path).unwrap();\n\n   // Define key-values for insertion\n   let key1 = b\"hello\";\n   let val1 = b\"world\";\n   let key2 = b\"grovedb\";\n   let val2 = b\"rocks\";\n\n   // Insert key-value 1 into the root tree\n   db.insert([], key1, Element::Item(val1.to_vec(), None), None, None)\n       .unwrap()\n       .expect(\"successful root tree leaf insert\");\n\n   // Insert key-value 2 into the root tree\n   db.insert([], key2, Element::Item(val2.to_vec(), None), None, None)\n       .unwrap()\n       .expect(\"successful root tree leaf 2 insert\");\n\n   // At this point the Items are fully inserted into the database.\n   // No other steps are required.\n\n   // To show that the Items are there, we will use the get()\n   // function to get them from the RocksDB backing store.\n\n   // Get value 1\n   let result1 = db.get([], key1, None).unwrap();\n\n   // Get value 2\n   let result2 = db.get([], key2, None).unwrap();\n\n   // Print the values to terminal\n   println!(\"{:?}\", result1);\n   println!(\"{:?}\", result2);\n}\n```\n\nThe terminal should output:\n\n``` text\nOk(item: [hex: 776f726c64, str: world])\nOk(item: [hex: 726f636b73, str: rocks])\n```\n\nThis tells us that at the given keys exist items with the shown hex and str values.\n\n# Element Enum\n\nIn the previous tutorial, we inserted strings as the values. However, values may be any of the five variants of the `Element` enum:\n\n``` rust\npub enum Element {\n    /// An ordinary value\n    Item(Vec<u8>, Option<ElementFlags>),\n    /// A reference to an object by its path\n    Reference(ReferencePathType, MaxReferenceHop, Option<ElementFlags>),\n    /// A subtree, contains the a prefixed key representing the root of the\n    /// subtree.\n    Tree(Option<Vec<u8>>, Option<ElementFlags>),\n    /// Signed integer value that can be totaled in a sum tree\n    SumItem(SumValue, Option<ElementFlags>),\n    /// Same as Element::Tree but underlying Merk sums value of it's summable\n    /// nodes\n    SumTree(Option<Vec<u8>>, SumValue, Option<ElementFlags>),\n}\n```\n\nFor example, instead of using `let val1 = b\"world\"`, we could have put `let val1 = Element::Tree(None, None)` and then put `val1` in the insert function instead of `Element::Item(val1.to_vec(), None)`.\n\nIn that case, the output would have returned:\n\n``` text\nOk(tree: None)\nOk(item: [hex: 726f636b73, str: rocks])\n```\n\n# Element Functions\n\nInstead of passing `Element::Item()` or some other `Element` enum to the `insert` function, we could also pass one of the functions implemented in `Element`, `new_item()`. Given an item value, the `new_item` function returns `Element::Item(item_value, None)`. It looks like this:\n\n``` rust\nimpl Element {\n    /// Set element to an item with a default flag value\n    pub fn new_item(item_value: Vec<u8>) -> Self {\n        Element::Item(item_value, None)\n    }\n}\n```\n\nAnd would be used like so:\n\n``` rust\n// Insert key-value 1 into the root tree\ndb.insert([], key1, Element::new_item(val1.to_vec()), None, None)\n   .unwrap()\n   .expect(\"successful root tree leaf insert\");\n```\n\nThe `new_item()` function is useful because it allows developers to set a default value for the flags. In our case it\u2019s `None`.\n\nThere are a few other [functions](https://github.com/dashpay/grovedb/blob/master/grovedb/src/element/constructor.rs) implemented in `Element` that can be used similarly. The `Element::empty_tree()` function is quite useful as well.",
 "order": 1,
 "isReference": false,
 "deprecated": false,
 "hidden": true,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "reusableContent": [],
 "previousSlug": "",
 "slugUpdatedAt": "2023-02-08T19:42:44.337Z",
 "revision": 6,
 "_id": "64f8a9df750465004742addc",
 "user": "5b8400d7185d5e00036dcc3b",
 "project": "5bda01cad172e200499a20a9",
 "parentDoc": "64f8a9df750465004742addb",
 "category": "64f8a9df750465004742ad6e",
 "createdAt": "2023-02-08T20:15:40.626Z",
 "updatedAt": "2023-03-07T18:06:09.672Z",
 "version": "64f8a9df750465004742ae1d",
 "__v": 0,
 "isApi": false,
 "id": "64f8a9df750465004742addc",
 "body_html": "<div class=\"magic-block-textarea\"><h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-tutorial\"></div>Tutorial<a class=\"fa fa-anchor\" href=\"#section-tutorial\"></a></h1>\n<p>GroveDB uses the <code>insert()</code> function to <a href=\"https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/insert/mod.rs\">insert</a> items into storage. Insert will also overwrite values unless the value is a tree. The function takes five arguments as shown below.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; Insert Element into GroveDB</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">insert</span><span class=\"cm-operator\">&lt;</span>'<span class=\"cm-variable\">p</span>, <span class=\"cm-variable\">P</span><span class=\"cm-operator\">&gt;</span>(\n   &amp;<span class=\"cm-keyword\">self</span>,\n   <span class=\"cm-comment\">&#47;&#47; Tree path to the subtree where the key-value should be inserted</span>\n   <span class=\"cm-variable\">path</span>: <span class=\"cm-variable\">P</span>,\n   <span class=\"cm-comment\">&#47;&#47; The key</span>\n   <span class=\"cm-variable\">key</span>: &amp;'<span class=\"cm-variable\">p</span> [<span class=\"cm-atom\">u8</span>],\n   <span class=\"cm-comment\">&#47;&#47; The value</span>\n   <span class=\"cm-variable\">element</span>: <span class=\"cm-variable\">Element</span>,\n   <span class=\"cm-comment\">&#47;&#47; Insert options</span>\n   <span class=\"cm-variable\">options</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">InsertOptions</span><span class=\"cm-operator\">&gt;</span>,\n   <span class=\"cm-comment\">&#47;&#47; Transaction that the insert operation should be included in</span>\n   <span class=\"cm-variable\">transaction</span>: <span class=\"cm-variable\">TransactionArg</span>,\n)</span>\n</code></pre>\n<p>This tutorial inserts two key-values into the root tree of the GroveDB instance created in Open Tutorial (or a new instance if you skipped Open Tutorial). The keys and values of both KVs are strings. Then for the purpose of showing they are there, it uses the <code>get()</code> function to retrieve the values and print them to the terminal.</p>\n<p>The following code can be run with <code>cargo run --bin insert</code>.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">GroveDb</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">Element</span>;\n\n<span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">main</span>() {\n\n   <span class=\"cm-comment\">&#47;&#47; Specify a path and open GroveDB at the path as db</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">String</span>::<span class=\"cm-variable\">from</span>(<span class=\"cm-string\">\"..&#47;storage\"</span>);\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">db</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">GroveDb</span>::<span class=\"cm-variable\">open</span>(<span class=\"cm-variable\">path</span>).<span class=\"cm-variable\">unwrap</span>();\n\n   <span class=\"cm-comment\">&#47;&#47; Define key-values for insertion</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">key1</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"hello\"</span>;\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">val1</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"world\"</span>;\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">key2</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"grovedb\"</span>;\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">val2</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"rocks\"</span>;\n\n   <span class=\"cm-comment\">&#47;&#47; Insert key-value 1 into the root tree</span>\n   <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([], <span class=\"cm-variable\">key1</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">Item</span>(<span class=\"cm-variable\">val1</span>.<span class=\"cm-variable\">to_vec</span>(), <span class=\"cm-builtin\">None</span>), <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n       .<span class=\"cm-variable\">unwrap</span>()\n       .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful root tree leaf insert\"</span>);\n\n   <span class=\"cm-comment\">&#47;&#47; Insert key-value 2 into the root tree</span>\n   <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([], <span class=\"cm-variable\">key2</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">Item</span>(<span class=\"cm-variable\">val2</span>.<span class=\"cm-variable\">to_vec</span>(), <span class=\"cm-builtin\">None</span>), <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n       .<span class=\"cm-variable\">unwrap</span>()\n       .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful root tree leaf 2 insert\"</span>);\n\n   <span class=\"cm-comment\">&#47;&#47; At this point the Items are fully inserted into the database.</span>\n   <span class=\"cm-comment\">&#47;&#47; No other steps are required.</span>\n\n   <span class=\"cm-comment\">&#47;&#47; To show that the Items are there, we will use the get()</span>\n   <span class=\"cm-comment\">&#47;&#47; function to get them from the RocksDB backing store.</span>\n\n   <span class=\"cm-comment\">&#47;&#47; Get value 1</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">result1</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">get</span>([], <span class=\"cm-variable\">key1</span>, <span class=\"cm-builtin\">None</span>).<span class=\"cm-variable\">unwrap</span>();\n\n   <span class=\"cm-comment\">&#47;&#47; Get value 2</span>\n   <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">result2</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">get</span>([], <span class=\"cm-variable\">key2</span>, <span class=\"cm-builtin\">None</span>).<span class=\"cm-variable\">unwrap</span>();\n\n   <span class=\"cm-comment\">&#47;&#47; Print the values to terminal</span>\n   <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"{:?}\"</span>, <span class=\"cm-variable\">result1</span>);\n   <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"{:?}\"</span>, <span class=\"cm-variable\">result2</span>);\n}</span>\n</code></pre>\n<p>The terminal should output:</p>\n<pre><code class=\"lang-text\">Ok(item: [hex: 776f726c64, str: world])\nOk(item: [hex: 726f636b73, str: rocks])\n</code></pre>\n<p>This tells us that at the given keys exist items with the shown hex and str values.</p>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-element-enum\"></div>Element Enum<a class=\"fa fa-anchor\" href=\"#section-element-enum\"></a></h1>\n<p>In the previous tutorial, we inserted strings as the values. However, values may be any of the five variants of the <code>Element</code> enum:</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">enum</span> <span class=\"cm-def\">Element</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; An ordinary value</span>\n    <span class=\"cm-variable\">Item</span>(<span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;</span>, <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">ElementFlags</span><span class=\"cm-operator\">&gt;</span>),\n    <span class=\"cm-comment\">&#47;&#47;&#47; A reference to an object by its path</span>\n    <span class=\"cm-variable\">Reference</span>(<span class=\"cm-variable\">ReferencePathType</span>, <span class=\"cm-variable\">MaxReferenceHop</span>, <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">ElementFlags</span><span class=\"cm-operator\">&gt;</span>),\n    <span class=\"cm-comment\">&#47;&#47;&#47; A subtree, contains the a prefixed key representing the root of the</span>\n    <span class=\"cm-comment\">&#47;&#47;&#47; subtree.</span>\n    <span class=\"cm-variable\">Tree</span>(<span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>, <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">ElementFlags</span><span class=\"cm-operator\">&gt;</span>),\n    <span class=\"cm-comment\">&#47;&#47;&#47; Signed integer value that can be totaled in a sum tree</span>\n    <span class=\"cm-variable\">SumItem</span>(<span class=\"cm-variable\">SumValue</span>, <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">ElementFlags</span><span class=\"cm-operator\">&gt;</span>),\n    <span class=\"cm-comment\">&#47;&#47;&#47; Same as Element::Tree but underlying Merk sums value of it's summable</span>\n    <span class=\"cm-comment\">&#47;&#47;&#47; nodes</span>\n    <span class=\"cm-variable\">SumTree</span>(<span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>, <span class=\"cm-variable\">SumValue</span>, <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">ElementFlags</span><span class=\"cm-operator\">&gt;</span>),\n}</span>\n</code></pre>\n<p>For example, instead of using <code>let val1 = b&quot;world&quot;</code>, we could have put <code>let val1 = Element::Tree(None, None)</code> and then put <code>val1</code> in the insert function instead of <code>Element::Item(val1.to_vec(), None)</code>.</p>\n<p>In that case, the output would have returned:</p>\n<pre><code class=\"lang-text\">Ok(tree: None)\nOk(item: [hex: 726f636b73, str: rocks])\n</code></pre>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-element-functions\"></div>Element Functions<a class=\"fa fa-anchor\" href=\"#section-element-functions\"></a></h1>\n<p>Instead of passing <code>Element::Item()</code> or some other <code>Element</code> enum to the <code>insert</code> function, we could also pass one of the functions implemented in <code>Element</code>, <code>new_item()</code>. Given an item value, the <code>new_item</code> function returns <code>Element::Item(item_value, None)</code>. It looks like this:</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">impl</span> <span class=\"cm-variable\">Element</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; Set element to an item with a default flag value</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">new_item</span>(<span class=\"cm-variable\">item_value</span>: <span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;</span>) <span class=\"cm-operator\">-&gt;</span> <span class=\"cm-atom\">Self</span> {\n        <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">Item</span>(<span class=\"cm-variable\">item_value</span>, <span class=\"cm-builtin\">None</span>)\n    }\n}</span>\n</code></pre>\n<p>And would be used like so:</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47; Insert key-value 1 into the root tree</span>\n<span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([], <span class=\"cm-variable\">key1</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">new_item</span>(<span class=\"cm-variable\">val1</span>.<span class=\"cm-variable\">to_vec</span>()), <span class=\"cm-builtin\">None</span>, <span class=\"cm-builtin\">None</span>)\n   .<span class=\"cm-variable\">unwrap</span>()\n   .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful root tree leaf insert\"</span>);</span>\n</code></pre>\n<p>The <code>new_item()</code> function is useful because it allows developers to set a default value for the flags. In our case it\u2019s <code>None</code>.</p>\n<p>There are a few other <a href=\"https://github.com/dashpay/grovedb/blob/master/grovedb/src/element/constructor.rs\">functions</a> implemented in <code>Element</code> that can be used similarly. The <code>Element::empty_tree()</code> function is quite useful as well.</p>\n\n</div>"
}