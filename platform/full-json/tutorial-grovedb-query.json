{
 "metadata": {
  "image": [],
  "title": "",
  "description": "",
  "keywords": "",
  "robots": "index"
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 200
    },
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 400
    }
   ]
  },
  "params": []
 },
 "next": {
  "description": "",
  "pages": []
 },
 "algolia": {
  "recordCount": 5,
  "publishPending": false,
  "updatedAt": "2023-09-06T16:36:48.854Z"
 },
 "title": "Query",
 "icon": "",
 "updates": [],
 "type": "basic",
 "slug": "tutorial-grovedb-query",
 "excerpt": "",
 "body": "# Query Function\n\nGroveDB generally uses the `query()` function to perform [queries](https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/get/query.rs) on storage. It takes four arguments as shown below.\n\n```\nimpl GroveDb {\n    /// Returns given path query results\n    pub fn query(\n        &self,\n        path_query: &PathQuery,\n        allow_cache: bool,\n        result_type: QueryResultType,\n        transaction: TransactionArg,\n    ) -> CostResult<(QueryResultElements, u16)\n}\n```\n\n# Explanations\n\nGroveDB queries can be very complex. This section gives explanations of each component of a path query. Deep understanding of each component isn\u2019t necessary to follow and learn from the tutorials, so, if you\u2019d rather learn by doing, feel free to [skip it](#simple-query-tutorial).\n\nA **path query**, which is the first argument of `query()`, has a path and a sized query as parameters. The path points to the highest-level subtree you want to query. You can traverse and recurse into lower-level subtrees within a path query using subqueries, as will be explained later.\n\n``` rust\n/// Path query\npub struct PathQuery {\n    /// Path\n    pub path: Vec<Vec<u8>>,\n    /// Query\n    pub query: SizedQuery,\n}\n```\n\nA **sized query**, which is the second argument of path queries, takes a query, limit, and offset as parameters. The limit is an integer which specifies the maximum number of results to return in the final result set. The offset is an integer which specifies how many items in the front of the raw result set to exclude from the final result set. In other words, the limit specifies a cut-off at the end of the raw result set, and offset specifies a cut-off at the beginning of the raw result set which, after applied, will compose the final result set. As implied, there is an ordering of the raw (and final) result set, which is defined in the other, first, parameter of a sized query: query.\n\n``` rust\n/// Sized query\npub struct SizedQuery {\n    /// Query\n    pub query: Query,\n    /// Limit\n    pub limit: Option<u16>,\n    /// Offset\n    pub offset: Option<u16>,\n}\n```\n\nA **query** takes a vector of query items as its first argument. A **query item** is either a key, set of keys, or a range. Items in these keys or ranges of keys will be added to the raw result set. Subtrees in these keys or ranges of keys are optionally handled with the next two parameters: the default subquery branch and the conditional subquery branch.\n\n``` rust\n/// A `Query` represents one or more keys or ranges of keys, which can be \n/// used to resolve a proof which will include all of the requested values.\npub struct Query {\n    /// Items\n    pub items: Vec<QueryItem>,\n    /// Default subquery branch\n    pub default_subquery_branch: SubqueryBranch,\n    /// Conditional subquery branches\n    pub conditional_subquery_branches: Option<IndexMap<QueryItem, SubqueryBranch>>,\n    /// Left to right?\n    pub left_to_right: bool,\n}\n\n/// A `QueryItem` represents a key or range of keys to be included in a proof.\npub enum QueryItem {\n    Key(Vec<u8>),\n    Range(Range<Vec<u8>>),\n    RangeInclusive(RangeInclusive<Vec<u8>>),\n    RangeFull(RangeFull),\n    RangeFrom(RangeFrom<Vec<u8>>),\n    RangeTo(RangeTo<Vec<u8>>),\n    RangeToInclusive(RangeToInclusive<Vec<u8>>),\n    RangeAfter(RangeFrom<Vec<u8>>),\n    RangeAfterTo(Range<Vec<u8>>),\n    RangeAfterToInclusive(RangeInclusive<Vec<u8>>),\n}\n```\n\nA **default subquery branch** has two parameters: a subquery path and a subquery. The subquery path is a path that is applied to all the subtrees in the result set from the higher-level query we just mentioned. The subquery is a query of the same type as the higher-level query which is applied to the subtrees at the end of the subquery path. The result set of the subquery branch is added to the overall result set. Since subqueries are the same as queries, they can recurse, so you can have subqueries within subqueries. Both subquery path and subquery are optional parameters of a subquery branch. If no subquery path is defined, the subquery applies to all the subtrees in the higher-level query result set. If no subquery is defined, all the elements from the subquery path subtrees are added to the result set.\n\n``` rust\n/// Subquery branch\npub struct SubqueryBranch {\n    /// Subquery path\n    pub subquery_path: Option<Path>,\n    /// Subquery\n    pub subquery: Option<Box<Query>>,\n}\n```\n\nA **conditional subquery branch** is the same as default subquery branches, but takes an additional argument for query items, which again are keys or ranges. The subquery branch is only applied to the subtrees which meet the condition of matching the query items.\n\nFinally, the last parameter of query is left_to_right, which is a boolean that defines the order of the result set. Left to right means lower to higher in terms of integers, or alphabetically in terms of strings.\n\nSee the [documentation](https://github.com/dashpay/grovedb/blob/master/README.md) for more details.\n\n# Get\n\nThe previous tutorials used a function `get()` to retrieve items from storage. _Getting_ only allows for the retrieval of one item, the key must be specified, and cryptographic proofs of _gets_ aren\u2019t supported. Queries, on the other hand, can return many values all at once, the keys don\u2019t need to be provided, and query results _can_ be cryptographically proven.\n\n``` rust\n/// Get an element from the backing store\npub fn get<'p, P>(\n    &self,\n    path: P,\n    key: &'p [u8],\n    transaction: TransactionArg,\n)\n```\n\n# Simple Query Tutorial\n\nThis tutorial populates GroveDB with values 0-99 in a subtree within a subtree within the root tree:\n\n```\n/// Root\n///    SUBTREE1\n///       SUBTREE2\n///          Values 0-99\n```\n\nIt then constructs and executes a query to retrieve a subset of the items and prints the query result to the terminal.\n\nThe following code can be run with ```cargo run --bin query-simple```.\n\n``` rust\nuse grovedb::operations::insert::InsertOptions;\nuse grovedb::Element;\nuse grovedb::GroveDb;\nuse grovedb::{PathQuery, Query};\n\nconst KEY1: &[u8] = b\"key1\";\nconst KEY2: &[u8] = b\"key2\";\n\n// Allow insertions to overwrite trees\n// This is necessary so the tutorial can be rerun easily\nconst INSERT_OPTIONS: Option<InsertOptions> = Some(InsertOptions {\n    validate_insertion_does_not_override: false,\n    validate_insertion_does_not_override_tree: false,\n    base_root_storage_is_free: true,\n});\n\nfn main() {\n    // Specify the path where the GroveDB instance exists.\n    let path = String::from(\"../storage\");\n\n    // Open GroveDB at the path.\n    let db = GroveDb::open(path).unwrap();\n\n    // Populate GroveDB with values. This function is defined below.\n    populate(&db);\n\n    // Define the path to the subtree we want to query.\n    let path = vec![KEY1.to_vec(), KEY2.to_vec()];\n\n    // Instantiate a new query.\n    let mut query = Query::new();\n\n    // Insert a range of keys to the query that we would like returned.\n    // In this case, we are asking for keys 30 through 34.\n    query.insert_range(30_u8.to_be_bytes().to_vec()..35_u8.to_be_bytes().to_vec());\n\n    // Put the query into a new unsized path query.\n    let path_query = PathQuery::new_unsized(path, query.clone());\n\n    // Execute the query and collect the result items in \"elements\".\n    let (elements, _) = db\n        .query_item_value(&path_query, true, None)\n        .unwrap()\n        .expect(\"expected successful get_path_query\");\n\n    // Print result items to terminal.\n    println!(\"{:?}\", elements);\n}\n\nfn populate(db: &GroveDb) {\n    // Put an empty subtree into the root tree nodes at KEY1.\n    // Call this SUBTREE1.\n    db.insert([], KEY1, Element::empty_tree(), INSERT_OPTIONS, None)\n        .unwrap()\n        .expect(\"successful SUBTREE1 insert\");\n\n    // Put an empty subtree into subtree1 at KEY2.\n    // Call this SUBTREE2.\n    db.insert([KEY1], KEY2, Element::empty_tree(), INSERT_OPTIONS, None)\n        .unwrap()\n        .expect(\"successful SUBTREE2 insert\");\n\n    // Populate SUBTREE2 with values 0 through 99 under keys 0 through 99.\n    for i in 0u8..100 {\n        let i_vec = (i as u8).to_be_bytes().to_vec();\n        db.insert(\n            [KEY1, KEY2],\n            &i_vec,\n            Element::new_item(i_vec.clone()),\n            INSERT_OPTIONS,\n            None,\n        )\n        .unwrap()\n        .expect(\"successfully inserted values\");\n    }\n}\n```\n\nThe terminal should output:\n\n``` text\n[[30], [31], [32], [33], [34]]\n```\n\n# Complex Query Tutorial\n\nThis tutorial populates GroveDB with the following tree structure:\n\n```\n/// Root\n///   SUBTREE1\n///      SUBTREE2\n///         Values 0-49 except random number 1\n///         SUBTREE3\n///            Values 50-74 except random number 2\n///            SUBTREE4\n///               SUBTREE5\n///                  Values 75-99\n```\n\nIt then queries SUBTREE2 for keys 20-30. Call this QUERY1.\n\nIt applies a conditional subquery to QUERY1, which says if any keys 20-25 are subtrees, navigate the subquery path and execute the subquery. Call this SUBQUERY1. No path is specified for SUBQUERY1, so the subquery is applied directly to the subtrees. The subquery asks for keys 60 and 70 from those subtrees.\n\nSay SUBTREE3 is located at key 22. The result set now looks like this:\n\n```\n[20,21,60,70,23,24,25,26,27,28,29,30]\n```\n\nIt then applies a conditional subquery to SUBQUERY1, which says if 60 is a subtree, navigate the subquery path and execute the subquery. Call this SUBQUERY2. SUBQUERY2 specifies to navigate through SUBTREE4 and execute the subquery on SUBTREE5. The subquery asks for keys 90 through 94.\n\nSay SUBTREE4 is located at key 60. The result set now looks like this:\n\n```\n[20,21,90,91,92,93,94,70,23,24,25,26,27,28,29,30]\n```\n\nQUERY1, SUBQUERY1, and SUBQUERY2 are then all put into a sized query, which sets a limit of 10 and an offset of 3. Limit of 10 means no more than 10 items can be included in the results. Offset of 3 means the first 3 pre-sized query results are omitted from the post-sized query results.\n\nThe final result set is:\n\n```\n[91,92,93,94,70,23,24,25,26,27]\n```\n\nThe sized query is then passed to the path query and the path query is executed.\n\nThe following code can be run with ```cargo run --bin query-complex```.\n\n``` rust\nuse grovedb::operations::insert::InsertOptions;\nuse grovedb::Element;\nuse grovedb::GroveDb;\nuse grovedb::{PathQuery, Query, QueryItem, SizedQuery};\nuse rand::Rng;\n\nconst KEY1: &[u8] = b\"key1\";\nconst KEY2: &[u8] = b\"key2\";\nconst KEY3: &[u8] = b\"key3\";\n\n// Allow insertions to overwrite trees\n// This is necessary so the tutorial can be rerun easily\nconst INSERT_OPTIONS: Option<InsertOptions> = Some(InsertOptions {\n    validate_insertion_does_not_override: false,\n    validate_insertion_does_not_override_tree: false,\n    base_root_storage_is_free: true,\n});\n\nfn main() {\n    // Specify the path where the GroveDB instance exists.\n    let path = String::from(\"../storage\");\n\n    // Open GroveDB at the path.\n    let db = GroveDb::open(path).unwrap();\n\n    // Populate GroveDB with values. This function is defined below.\n    populate(&db);\n\n    // Define the path to the highest-level subtree we want to query.\n    let path = vec![KEY1.to_vec(), KEY2.to_vec()];\n\n    // Instantiate new queries.\n    let mut query = Query::new();\n    let mut subquery = Query::new();\n    let mut subquery2 = Query::new();\n\n    // Insert query items into the queries.\n    // Query 20-30 at path.\n    query.insert_range(20_u8.to_be_bytes().to_vec()..31_u8.to_be_bytes().to_vec());\n    // If any 20-30 are subtrees and meet the subquery condition,\n    // follow the path and query 60, 70 from there.\n    subquery.insert_keys(vec![vec![60], vec![70]]);\n    // If either 60, 70 are subtrees and meet the subquery condition,\n    // follow the path and query 90-94 from there.\n    subquery2.insert_range(90_u8.to_be_bytes().to_vec()..95_u8.to_be_bytes().to_vec());\n\n    // Add subquery branches.\n    // If 60 is a subtree, navigate through SUBTREE4 and run subquery2 on SUBTREE5.\n    subquery.add_conditional_subquery(QueryItem::Key(vec![60]), Some(vec!(KEY3.to_vec())), Some(subquery2));\n    // If anything up to and including 25 is a subtree, run subquery on it. No path.\n    query.add_conditional_subquery(\n        QueryItem::RangeToInclusive(std::ops::RangeToInclusive { end: vec![25] }),\n        None,\n        Some(subquery),\n    );\n\n    // Put the query into a sized query. Limit the result set to 10,\n    // and impose an offset of 3.\n    let sized_query = SizedQuery::new(query, Some(10), Some(3));\n\n    // Put the sized query into a new path query.\n    let path_query = PathQuery::new(path, sized_query.clone());\n\n    // Execute the path query and collect the result items in \"elements\".\n    let (elements, _) = db\n        .query_item_value(&path_query, true, None)\n        .unwrap()\n        .expect(\"expected successful get_path_query\");\n\n    // Print result items to terminal.\n    println!(\"{:?}\", elements);\n}\n\nfn populate(db: &GroveDb) {\n    // Put an empty subtree into the root tree nodes at KEY1.\n    // Call this SUBTREE1.\n    db.insert([], KEY1, Element::empty_tree(), INSERT_OPTIONS, None)\n        .unwrap()\n        .expect(\"successful SUBTREE1 insert\");\n\n    // Put an empty subtree into subtree1 at KEY2.\n    // Call this SUBTREE2.\n    db.insert([KEY1], KEY2, Element::empty_tree(), INSERT_OPTIONS, None)\n        .unwrap()\n        .expect(\"successful SUBTREE2 insert\");\n\n    // Populate SUBTREE2 with values 0 through 49 under keys 0 through 49.\n    for i in 0u8..50 {\n        let i_vec = (i as u8).to_be_bytes().to_vec();\n        db.insert(\n            [KEY1, KEY2],\n            &i_vec,\n            Element::new_item(i_vec.clone()),\n            INSERT_OPTIONS,\n            None,\n        )\n        .unwrap()\n        .expect(\"successfully inserted values in SUBTREE2\");\n    }\n\n    // Set random_numbers\n    let mut rng = rand::thread_rng();\n    let rn1: &[u8] = &(rng.gen_range(15..26) as u8).to_be_bytes();\n    let rn2: &[u8] = &(rng.gen_range(60..62) as u8).to_be_bytes();\n\n    // Overwrite key rn1 with a subtree\n    // Call this SUBTREE3\n    db.insert(\n        [KEY1, KEY2],\n        &rn1,\n        Element::empty_tree(),\n        INSERT_OPTIONS,\n        None,\n    )\n    .unwrap()\n    .expect(\"successful SUBTREE3 insert\");\n\n    // Populate SUBTREE3 with values 50 through 74 under keys 50 through 74\n    for i in 50u8..75 {\n        let i_vec = (i as u8).to_be_bytes().to_vec();\n        db.insert(\n            [KEY1, KEY2, rn1],\n            &i_vec,\n            Element::new_item(i_vec.clone()),\n            INSERT_OPTIONS,\n            None,\n        )\n        .unwrap()\n        .expect(\"successfully inserted values in SUBTREE3\");\n    }\n\n    // Overwrite key rn2 with a subtree\n    // Call this SUBTREE4\n    db.insert(\n        [KEY1, KEY2, rn1],\n        &rn2,\n        Element::empty_tree(),\n        INSERT_OPTIONS,\n        None,\n    )\n    .unwrap()\n    .expect(\"successful SUBTREE4 insert\");\n\n    // Put an empty subtree into SUBTREE4 at KEY3.\n    // Call this SUBTREE5.\n    db.insert([KEY1, KEY2, rn1, rn2], KEY3, Element::empty_tree(), INSERT_OPTIONS, None)\n        .unwrap()\n        .expect(\"successful SUBTREE5 insert\");\n\n    // Populate SUBTREE5 with values 75 through 99 under keys 75 through 99\n    for i in 75u8..99 {\n        let i_vec = (i as u8).to_be_bytes().to_vec();\n        db.insert(\n            [KEY1, KEY2, rn1, rn2, KEY3],\n            &i_vec,\n            Element::new_item(i_vec.clone()),\n            INSERT_OPTIONS,\n            None,\n        )\n        .unwrap()\n        .expect(\"successfully inserted values in SUBTREE5\");\n    }\n}\n```\n\nThe terminal output depends on which random numbers were generated. A few of the possibilities are shown below.\n\nRandom number 1 does not fall between 20-25:\n\n```\n[[22], [23], [24], [25], [26], [27], [28], [29]]\n```\n\nRandom number 1 is 23, random number 2 is not 60:\n\n```\n[[60], [70], [24], [25], [26], [27], [28], [29]]\n```\n\nRandom number 1 is 21, random number 2 is 60:\n\n```\n[[92], [93], [94], [70], [22], [23], [24], [25], [26], [27]]\n```",
 "order": 3,
 "isReference": false,
 "deprecated": false,
 "hidden": true,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "reusableContent": [],
 "previousSlug": "",
 "slugUpdatedAt": "2023-02-08T19:25:15.971Z",
 "revision": 5,
 "_id": "64f8a9df750465004742adde",
 "user": "5b8400d7185d5e00036dcc3b",
 "project": "5bda01cad172e200499a20a9",
 "parentDoc": "64f8a9df750465004742addb",
 "category": "64f8a9df750465004742ad6e",
 "createdAt": "2023-02-08T20:21:32.002Z",
 "updatedAt": "2023-03-07T18:03:33.818Z",
 "version": "64f8a9df750465004742ae1d",
 "__v": 0,
 "isApi": false,
 "id": "64f8a9df750465004742adde",
 "body_html": "<div class=\"magic-block-textarea\"><h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-query-function\"></div>Query Function<a class=\"fa fa-anchor\" href=\"#section-query-function\"></a></h1>\n<p>GroveDB generally uses the <code>query()</code> function to perform <a href=\"https://github.com/dashpay/grovedb/blob/009787b79538dae833ed6711253852046dfcc59d/grovedb/src/operations/get/query.rs\">queries</a> on storage. It takes four arguments as shown below.</p>\n<pre><code>impl GroveDb {\n    /// Returns given path query results\n    pub fn query(\n        &amp;self,\n        path_query: &amp;PathQuery,\n        allow_cache: bool,\n        result_type: QueryResultType,\n        transaction: TransactionArg,\n    ) -&gt; CostResult&lt;(QueryResultElements, u16)\n}\n</code></pre><h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-explanations\"></div>Explanations<a class=\"fa fa-anchor\" href=\"#section-explanations\"></a></h1>\n<p>GroveDB queries can be very complex. This section gives explanations of each component of a path query. Deep understanding of each component isn\u2019t necessary to follow and learn from the tutorials, so, if you\u2019d rather learn by doing, feel free to <a href=\"#simple-query-tutorial\">skip it</a>.</p>\n<p>A <strong>path query</strong>, which is the first argument of <code>query()</code>, has a path and a sized query as parameters. The path points to the highest-level subtree you want to query. You can traverse and recurse into lower-level subtrees within a path query using subqueries, as will be explained later.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; Path query</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">struct</span> <span class=\"cm-def\">PathQuery</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; Path</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">path</span>: <span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Query</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">query</span>: <span class=\"cm-variable\">SizedQuery</span>,\n}</span>\n</code></pre>\n<p>A <strong>sized query</strong>, which is the second argument of path queries, takes a query, limit, and offset as parameters. The limit is an integer which specifies the maximum number of results to return in the final result set. The offset is an integer which specifies how many items in the front of the raw result set to exclude from the final result set. In other words, the limit specifies a cut-off at the end of the raw result set, and offset specifies a cut-off at the beginning of the raw result set which, after applied, will compose the final result set. As implied, there is an ordering of the raw (and final) result set, which is defined in the other, first, parameter of a sized query: query.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; Sized query</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">struct</span> <span class=\"cm-def\">SizedQuery</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; Query</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">query</span>: <span class=\"cm-variable\">Query</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Limit</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">limit</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u16</span><span class=\"cm-operator\">&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Offset</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">offset</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u16</span><span class=\"cm-operator\">&gt;</span>,\n}</span>\n</code></pre>\n<p>A <strong>query</strong> takes a vector of query items as its first argument. A <strong>query item</strong> is either a key, set of keys, or a range. Items in these keys or ranges of keys will be added to the raw result set. Subtrees in these keys or ranges of keys are optionally handled with the next two parameters: the default subquery branch and the conditional subquery branch.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; A `Query` represents one or more keys or ranges of keys, which can be </span>\n<span class=\"cm-comment\">&#47;&#47;&#47; used to resolve a proof which will include all of the requested values.</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">struct</span> <span class=\"cm-def\">Query</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; Items</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">items</span>: <span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">QueryItem</span><span class=\"cm-operator\">&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Default subquery branch</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">default_subquery_branch</span>: <span class=\"cm-variable\">SubqueryBranch</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Conditional subquery branches</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">conditional_subquery_branches</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">IndexMap</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">QueryItem</span>, <span class=\"cm-variable\">SubqueryBranch</span><span class=\"cm-operator\">&gt;&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Left to right?</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">left_to_right</span>: <span class=\"cm-atom\">bool</span>,\n}\n\n<span class=\"cm-comment\">&#47;&#47;&#47; A `QueryItem` represents a key or range of keys to be included in a proof.</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">enum</span> <span class=\"cm-def\">QueryItem</span> {\n    <span class=\"cm-variable\">Key</span>(<span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;</span>),\n    <span class=\"cm-variable\">Range</span>(<span class=\"cm-variable\">Range</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeInclusive</span>(<span class=\"cm-variable\">RangeInclusive</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeFull</span>(<span class=\"cm-variable\">RangeFull</span>),\n    <span class=\"cm-variable\">RangeFrom</span>(<span class=\"cm-variable\">RangeFrom</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeTo</span>(<span class=\"cm-variable\">RangeTo</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeToInclusive</span>(<span class=\"cm-variable\">RangeToInclusive</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeAfter</span>(<span class=\"cm-variable\">RangeFrom</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeAfterTo</span>(<span class=\"cm-variable\">Range</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n    <span class=\"cm-variable\">RangeAfterToInclusive</span>(<span class=\"cm-variable\">RangeInclusive</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Vec</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-atom\">u8</span><span class=\"cm-operator\">&gt;&gt;</span>),\n}</span>\n</code></pre>\n<p>A <strong>default subquery branch</strong> has two parameters: a subquery path and a subquery. The subquery path is a path that is applied to all the subtrees in the result set from the higher-level query we just mentioned. The subquery is a query of the same type as the higher-level query which is applied to the subtrees at the end of the subquery path. The result set of the subquery branch is added to the overall result set. Since subqueries are the same as queries, they can recurse, so you can have subqueries within subqueries. Both subquery path and subquery are optional parameters of a subquery branch. If no subquery path is defined, the subquery applies to all the subtrees in the higher-level query result set. If no subquery is defined, all the elements from the subquery path subtrees are added to the result set.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; Subquery branch</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">struct</span> <span class=\"cm-def\">SubqueryBranch</span> {\n    <span class=\"cm-comment\">&#47;&#47;&#47; Subquery path</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">subquery_path</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Path</span><span class=\"cm-operator\">&gt;</span>,\n    <span class=\"cm-comment\">&#47;&#47;&#47; Subquery</span>\n    <span class=\"cm-keyword\">pub</span> <span class=\"cm-variable\">subquery</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Box</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">Query</span><span class=\"cm-operator\">&gt;&gt;</span>,\n}</span>\n</code></pre>\n<p>A <strong>conditional subquery branch</strong> is the same as default subquery branches, but takes an additional argument for query items, which again are keys or ranges. The subquery branch is only applied to the subtrees which meet the condition of matching the query items.</p>\n<p>Finally, the last parameter of query is left_to_right, which is a boolean that defines the order of the result set. Left to right means lower to higher in terms of integers, or alphabetically in terms of strings.</p>\n<p>See the <a href=\"https://github.com/dashpay/grovedb/blob/master/README.md\">documentation</a> for more details.</p>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-get\"></div>Get<a class=\"fa fa-anchor\" href=\"#section-get\"></a></h1>\n<p>The previous tutorials used a function <code>get()</code> to retrieve items from storage. <em>Getting</em> only allows for the retrieval of one item, the key must be specified, and cryptographic proofs of <em>gets</em> aren\u2019t supported. Queries, on the other hand, can return many values all at once, the keys don\u2019t need to be provided, and query results <em>can</em> be cryptographically proven.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-comment\">&#47;&#47;&#47; Get an element from the backing store</span>\n<span class=\"cm-keyword\">pub</span> <span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">get</span><span class=\"cm-operator\">&lt;</span>'<span class=\"cm-variable\">p</span>, <span class=\"cm-variable\">P</span><span class=\"cm-operator\">&gt;</span>(\n    &amp;<span class=\"cm-keyword\">self</span>,\n    <span class=\"cm-variable\">path</span>: <span class=\"cm-variable\">P</span>,\n    <span class=\"cm-variable\">key</span>: &amp;'<span class=\"cm-variable\">p</span> [<span class=\"cm-atom\">u8</span>],\n    <span class=\"cm-variable\">transaction</span>: <span class=\"cm-variable\">TransactionArg</span>,\n)</span>\n</code></pre>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-simple-query-tutorial\"></div>Simple Query Tutorial<a class=\"fa fa-anchor\" href=\"#section-simple-query-tutorial\"></a></h1>\n<p>This tutorial populates GroveDB with values 0-99 in a subtree within a subtree within the root tree:</p>\n<pre><code>/// Root\n///    SUBTREE1\n///       SUBTREE2\n///          Values 0-99\n</code></pre><p>It then constructs and executes a query to retrieve a subset of the items and prints the query result to the terminal.</p>\n<p>The following code can be run with <code>cargo run --bin query-simple</code>.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">operations</span>::<span class=\"cm-variable\">insert</span>::<span class=\"cm-variable\">InsertOptions</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">Element</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">GroveDb</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::{<span class=\"cm-variable\">PathQuery</span>, <span class=\"cm-variable\">Query</span>};\n\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">KEY1</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"key1\"</span>;\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">KEY2</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"key2\"</span>;\n\n<span class=\"cm-comment\">&#47;&#47; Allow insertions to overwrite trees</span>\n<span class=\"cm-comment\">&#47;&#47; This is necessary so the tutorial can be rerun easily</span>\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">INSERT_OPTIONS</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">InsertOptions</span><span class=\"cm-operator\">&gt;</span> <span class=\"cm-operator\">=</span> <span class=\"cm-builtin\">Some</span>(<span class=\"cm-variable\">InsertOptions</span> {\n    <span class=\"cm-variable\">validate_insertion_does_not_override</span>: <span class=\"cm-builtin\">false</span>,\n    <span class=\"cm-variable\">validate_insertion_does_not_override_tree</span>: <span class=\"cm-builtin\">false</span>,\n    <span class=\"cm-variable\">base_root_storage_is_free</span>: <span class=\"cm-builtin\">true</span>,\n});\n\n<span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">main</span>() {\n    <span class=\"cm-comment\">&#47;&#47; Specify the path where the GroveDB instance exists.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">String</span>::<span class=\"cm-variable\">from</span>(<span class=\"cm-string\">\"..&#47;storage\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Open GroveDB at the path.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">db</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">GroveDb</span>::<span class=\"cm-variable\">open</span>(<span class=\"cm-variable\">path</span>).<span class=\"cm-variable\">unwrap</span>();\n\n    <span class=\"cm-comment\">&#47;&#47; Populate GroveDB with values. This function is defined below.</span>\n    <span class=\"cm-variable\">populate</span>(&amp;<span class=\"cm-variable\">db</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Define the path to the subtree we want to query.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-3\">vec!</span>[<span class=\"cm-variable\">KEY1</span>.<span class=\"cm-variable\">to_vec</span>(), <span class=\"cm-variable\">KEY2</span>.<span class=\"cm-variable\">to_vec</span>()];\n\n    <span class=\"cm-comment\">&#47;&#47; Instantiate a new query.</span>\n    <span class=\"cm-keyword\">let mut</span> <span class=\"cm-def\">query</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">Query</span>::<span class=\"cm-variable\">new</span>();\n\n    <span class=\"cm-comment\">&#47;&#47; Insert a range of keys to the query that we would like returned.</span>\n    <span class=\"cm-comment\">&#47;&#47; In this case, we are asking for keys 30 through 34.</span>\n    <span class=\"cm-variable\">query</span>.<span class=\"cm-variable\">insert_range</span>(<span class=\"cm-number\">30_u8</span>.<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>()..<span class=\"cm-number\">35_u8</span>.<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>());\n\n    <span class=\"cm-comment\">&#47;&#47; Put the query into a new unsized path query.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path_query</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">PathQuery</span>::<span class=\"cm-variable\">new_unsized</span>(<span class=\"cm-variable\">path</span>, <span class=\"cm-variable\">query</span>.<span class=\"cm-variable\">clone</span>());\n\n    <span class=\"cm-comment\">&#47;&#47; Execute the query and collect the result items in \"elements\".</span>\n    <span class=\"cm-variable\">let</span> (<span class=\"cm-variable\">elements</span>, <span class=\"cm-variable\">_</span>) <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>\n        .<span class=\"cm-variable\">query_item_value</span>(&amp;<span class=\"cm-variable\">path_query</span>, <span class=\"cm-builtin\">true</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"expected successful get_path_query\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Print result items to terminal.</span>\n    <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"{:?}\"</span>, <span class=\"cm-variable\">elements</span>);\n}\n\n<span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">populate</span>(<span class=\"cm-variable\">db</span>: &amp;<span class=\"cm-variable\">GroveDb</span>) {\n    <span class=\"cm-comment\">&#47;&#47; Put an empty subtree into the root tree nodes at KEY1.</span>\n    <span class=\"cm-comment\">&#47;&#47; Call this SUBTREE1.</span>\n    <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([], <span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">empty_tree</span>(), <span class=\"cm-variable\">INSERT_OPTIONS</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful SUBTREE1 insert\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Put an empty subtree into subtree1 at KEY2.</span>\n    <span class=\"cm-comment\">&#47;&#47; Call this SUBTREE2.</span>\n    <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([<span class=\"cm-variable\">KEY1</span>], <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">empty_tree</span>(), <span class=\"cm-variable\">INSERT_OPTIONS</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful SUBTREE2 insert\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Populate SUBTREE2 with values 0 through 99 under keys 0 through 99.</span>\n    <span class=\"cm-keyword\">for</span> <span class=\"cm-variable\">i</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-number\">0u8</span>..<span class=\"cm-number\">100</span> {\n        <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">i_vec</span> <span class=\"cm-operator\">=</span> (<span class=\"cm-variable\">i</span> <span class=\"cm-keyword\">as</span> <span class=\"cm-atom\">u8</span>).<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>();\n        <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>(\n            [<span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">KEY2</span>],\n            &amp;<span class=\"cm-variable\">i_vec</span>,\n            <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">new_item</span>(<span class=\"cm-variable\">i_vec</span>.<span class=\"cm-variable\">clone</span>()),\n            <span class=\"cm-variable\">INSERT_OPTIONS</span>,\n            <span class=\"cm-builtin\">None</span>,\n        )\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successfully inserted values\"</span>);\n    }\n}</span>\n</code></pre>\n<p>The terminal should output:</p>\n<pre><code class=\"lang-text\">[[30], [31], [32], [33], [34]]\n</code></pre>\n<h1 class=\"header-scroll\"><div class=\"anchor waypoint\" id=\"section-complex-query-tutorial\"></div>Complex Query Tutorial<a class=\"fa fa-anchor\" href=\"#section-complex-query-tutorial\"></a></h1>\n<p>This tutorial populates GroveDB with the following tree structure:</p>\n<pre><code>/// Root\n///   SUBTREE1\n///      SUBTREE2\n///         Values 0-49 except random number 1\n///         SUBTREE3\n///            Values 50-74 except random number 2\n///            SUBTREE4\n///               SUBTREE5\n///                  Values 75-99\n</code></pre><p>It then queries SUBTREE2 for keys 20-30. Call this QUERY1.</p>\n<p>It applies a conditional subquery to QUERY1, which says if any keys 20-25 are subtrees, navigate the subquery path and execute the subquery. Call this SUBQUERY1. No path is specified for SUBQUERY1, so the subquery is applied directly to the subtrees. The subquery asks for keys 60 and 70 from those subtrees.</p>\n<p>Say SUBTREE3 is located at key 22. The result set now looks like this:</p>\n<pre><code>[20,21,60,70,23,24,25,26,27,28,29,30]\n</code></pre><p>It then applies a conditional subquery to SUBQUERY1, which says if 60 is a subtree, navigate the subquery path and execute the subquery. Call this SUBQUERY2. SUBQUERY2 specifies to navigate through SUBTREE4 and execute the subquery on SUBTREE5. The subquery asks for keys 90 through 94.</p>\n<p>Say SUBTREE4 is located at key 60. The result set now looks like this:</p>\n<pre><code>[20,21,90,91,92,93,94,70,23,24,25,26,27,28,29,30]\n</code></pre><p>QUERY1, SUBQUERY1, and SUBQUERY2 are then all put into a sized query, which sets a limit of 10 and an offset of 3. Limit of 10 means no more than 10 items can be included in the results. Offset of 3 means the first 3 pre-sized query results are omitted from the post-sized query results.</p>\n<p>The final result set is:</p>\n<pre><code>[91,92,93,94,70,23,24,25,26,27]\n</code></pre><p>The sized query is then passed to the path query and the path query is executed.</p>\n<p>The following code can be run with <code>cargo run --bin query-complex</code>.</p>\n<pre><code class=\"lang-rust\"><span class='cm-s-neo'><span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">operations</span>::<span class=\"cm-variable\">insert</span>::<span class=\"cm-variable\">InsertOptions</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">Element</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::<span class=\"cm-variable\">GroveDb</span>;\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">grovedb</span>::{<span class=\"cm-variable\">PathQuery</span>, <span class=\"cm-variable\">Query</span>, <span class=\"cm-variable\">QueryItem</span>, <span class=\"cm-variable\">SizedQuery</span>};\n<span class=\"cm-keyword\">use</span> <span class=\"cm-variable\">rand</span>::<span class=\"cm-variable\">Rng</span>;\n\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">KEY1</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"key1\"</span>;\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">KEY2</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"key2\"</span>;\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">KEY3</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> <span class=\"cm-string\">b\"key3\"</span>;\n\n<span class=\"cm-comment\">&#47;&#47; Allow insertions to overwrite trees</span>\n<span class=\"cm-comment\">&#47;&#47; This is necessary so the tutorial can be rerun easily</span>\n<span class=\"cm-keyword\">const</span> <span class=\"cm-variable\">INSERT_OPTIONS</span>: <span class=\"cm-atom\">Option</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable\">InsertOptions</span><span class=\"cm-operator\">&gt;</span> <span class=\"cm-operator\">=</span> <span class=\"cm-builtin\">Some</span>(<span class=\"cm-variable\">InsertOptions</span> {\n    <span class=\"cm-variable\">validate_insertion_does_not_override</span>: <span class=\"cm-builtin\">false</span>,\n    <span class=\"cm-variable\">validate_insertion_does_not_override_tree</span>: <span class=\"cm-builtin\">false</span>,\n    <span class=\"cm-variable\">base_root_storage_is_free</span>: <span class=\"cm-builtin\">true</span>,\n});\n\n<span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">main</span>() {\n    <span class=\"cm-comment\">&#47;&#47; Specify the path where the GroveDB instance exists.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">String</span>::<span class=\"cm-variable\">from</span>(<span class=\"cm-string\">\"..&#47;storage\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Open GroveDB at the path.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">db</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">GroveDb</span>::<span class=\"cm-variable\">open</span>(<span class=\"cm-variable\">path</span>).<span class=\"cm-variable\">unwrap</span>();\n\n    <span class=\"cm-comment\">&#47;&#47; Populate GroveDB with values. This function is defined below.</span>\n    <span class=\"cm-variable\">populate</span>(&amp;<span class=\"cm-variable\">db</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Define the path to the highest-level subtree we want to query.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable-3\">vec!</span>[<span class=\"cm-variable\">KEY1</span>.<span class=\"cm-variable\">to_vec</span>(), <span class=\"cm-variable\">KEY2</span>.<span class=\"cm-variable\">to_vec</span>()];\n\n    <span class=\"cm-comment\">&#47;&#47; Instantiate new queries.</span>\n    <span class=\"cm-keyword\">let mut</span> <span class=\"cm-def\">query</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">Query</span>::<span class=\"cm-variable\">new</span>();\n    <span class=\"cm-keyword\">let mut</span> <span class=\"cm-def\">subquery</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">Query</span>::<span class=\"cm-variable\">new</span>();\n    <span class=\"cm-keyword\">let mut</span> <span class=\"cm-def\">subquery2</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">Query</span>::<span class=\"cm-variable\">new</span>();\n\n    <span class=\"cm-comment\">&#47;&#47; Insert query items into the queries.</span>\n    <span class=\"cm-comment\">&#47;&#47; Query 20-30 at path.</span>\n    <span class=\"cm-variable\">query</span>.<span class=\"cm-variable\">insert_range</span>(<span class=\"cm-number\">20_u8</span>.<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>()..<span class=\"cm-number\">31_u8</span>.<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>());\n    <span class=\"cm-comment\">&#47;&#47; If any 20-30 are subtrees and meet the subquery condition,</span>\n    <span class=\"cm-comment\">&#47;&#47; follow the path and query 60, 70 from there.</span>\n    <span class=\"cm-variable\">subquery</span>.<span class=\"cm-variable\">insert_keys</span>(<span class=\"cm-variable-3\">vec!</span>[<span class=\"cm-variable-3\">vec!</span>[<span class=\"cm-number\">60</span>], <span class=\"cm-variable-3\">vec!</span>[<span class=\"cm-number\">70</span>]]);\n    <span class=\"cm-comment\">&#47;&#47; If either 60, 70 are subtrees and meet the subquery condition,</span>\n    <span class=\"cm-comment\">&#47;&#47; follow the path and query 90-94 from there.</span>\n    <span class=\"cm-variable\">subquery2</span>.<span class=\"cm-variable\">insert_range</span>(<span class=\"cm-number\">90_u8</span>.<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>()..<span class=\"cm-number\">95_u8</span>.<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>());\n\n    <span class=\"cm-comment\">&#47;&#47; Add subquery branches.</span>\n    <span class=\"cm-comment\">&#47;&#47; If 60 is a subtree, navigate through SUBTREE4 and run subquery2 on SUBTREE5.</span>\n    <span class=\"cm-variable\">subquery</span>.<span class=\"cm-variable\">add_conditional_subquery</span>(<span class=\"cm-variable\">QueryItem</span>::<span class=\"cm-variable\">Key</span>(<span class=\"cm-variable-3\">vec!</span>[<span class=\"cm-number\">60</span>]), <span class=\"cm-builtin\">Some</span>(<span class=\"cm-variable-3\">vec!</span>(<span class=\"cm-variable\">KEY3</span>.<span class=\"cm-variable\">to_vec</span>())), <span class=\"cm-builtin\">Some</span>(<span class=\"cm-variable\">subquery2</span>));\n    <span class=\"cm-comment\">&#47;&#47; If anything up to and including 25 is a subtree, run subquery on it. No path.</span>\n    <span class=\"cm-variable\">query</span>.<span class=\"cm-variable\">add_conditional_subquery</span>(\n        <span class=\"cm-variable\">QueryItem</span>::<span class=\"cm-variable\">RangeToInclusive</span>(<span class=\"cm-variable\">std</span>::<span class=\"cm-variable\">ops</span>::<span class=\"cm-variable\">RangeToInclusive</span> { <span class=\"cm-variable\">end</span>: <span class=\"cm-variable-3\">vec!</span>[<span class=\"cm-number\">25</span>] }),\n        <span class=\"cm-builtin\">None</span>,\n        <span class=\"cm-builtin\">Some</span>(<span class=\"cm-variable\">subquery</span>),\n    );\n\n    <span class=\"cm-comment\">&#47;&#47; Put the query into a sized query. Limit the result set to 10,</span>\n    <span class=\"cm-comment\">&#47;&#47; and impose an offset of 3.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">sized_query</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">SizedQuery</span>::<span class=\"cm-variable\">new</span>(<span class=\"cm-variable\">query</span>, <span class=\"cm-builtin\">Some</span>(<span class=\"cm-number\">10</span>), <span class=\"cm-builtin\">Some</span>(<span class=\"cm-number\">3</span>));\n\n    <span class=\"cm-comment\">&#47;&#47; Put the sized query into a new path query.</span>\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">path_query</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">PathQuery</span>::<span class=\"cm-variable\">new</span>(<span class=\"cm-variable\">path</span>, <span class=\"cm-variable\">sized_query</span>.<span class=\"cm-variable\">clone</span>());\n\n    <span class=\"cm-comment\">&#47;&#47; Execute the path query and collect the result items in \"elements\".</span>\n    <span class=\"cm-variable\">let</span> (<span class=\"cm-variable\">elements</span>, <span class=\"cm-variable\">_</span>) <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">db</span>\n        .<span class=\"cm-variable\">query_item_value</span>(&amp;<span class=\"cm-variable\">path_query</span>, <span class=\"cm-builtin\">true</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"expected successful get_path_query\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Print result items to terminal.</span>\n    <span class=\"cm-variable-3\">println!</span>(<span class=\"cm-string\">\"{:?}\"</span>, <span class=\"cm-variable\">elements</span>);\n}\n\n<span class=\"cm-keyword\">fn</span> <span class=\"cm-def\">populate</span>(<span class=\"cm-variable\">db</span>: &amp;<span class=\"cm-variable\">GroveDb</span>) {\n    <span class=\"cm-comment\">&#47;&#47; Put an empty subtree into the root tree nodes at KEY1.</span>\n    <span class=\"cm-comment\">&#47;&#47; Call this SUBTREE1.</span>\n    <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([], <span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">empty_tree</span>(), <span class=\"cm-variable\">INSERT_OPTIONS</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful SUBTREE1 insert\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Put an empty subtree into subtree1 at KEY2.</span>\n    <span class=\"cm-comment\">&#47;&#47; Call this SUBTREE2.</span>\n    <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([<span class=\"cm-variable\">KEY1</span>], <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">empty_tree</span>(), <span class=\"cm-variable\">INSERT_OPTIONS</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful SUBTREE2 insert\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Populate SUBTREE2 with values 0 through 49 under keys 0 through 49.</span>\n    <span class=\"cm-keyword\">for</span> <span class=\"cm-variable\">i</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-number\">0u8</span>..<span class=\"cm-number\">50</span> {\n        <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">i_vec</span> <span class=\"cm-operator\">=</span> (<span class=\"cm-variable\">i</span> <span class=\"cm-keyword\">as</span> <span class=\"cm-atom\">u8</span>).<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>();\n        <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>(\n            [<span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">KEY2</span>],\n            &amp;<span class=\"cm-variable\">i_vec</span>,\n            <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">new_item</span>(<span class=\"cm-variable\">i_vec</span>.<span class=\"cm-variable\">clone</span>()),\n            <span class=\"cm-variable\">INSERT_OPTIONS</span>,\n            <span class=\"cm-builtin\">None</span>,\n        )\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successfully inserted values in SUBTREE2\"</span>);\n    }\n\n    <span class=\"cm-comment\">&#47;&#47; Set random_numbers</span>\n    <span class=\"cm-keyword\">let mut</span> <span class=\"cm-def\">rng</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">rand</span>::<span class=\"cm-variable\">thread_rng</span>();\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">rn1</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> &amp;(<span class=\"cm-variable\">rng</span>.<span class=\"cm-variable\">gen_range</span>(<span class=\"cm-number\">15</span>..<span class=\"cm-number\">26</span>) <span class=\"cm-keyword\">as</span> <span class=\"cm-atom\">u8</span>).<span class=\"cm-variable\">to_be_bytes</span>();\n    <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">rn2</span>: &amp;[<span class=\"cm-atom\">u8</span>] <span class=\"cm-operator\">=</span> &amp;(<span class=\"cm-variable\">rng</span>.<span class=\"cm-variable\">gen_range</span>(<span class=\"cm-number\">60</span>..<span class=\"cm-number\">62</span>) <span class=\"cm-keyword\">as</span> <span class=\"cm-atom\">u8</span>).<span class=\"cm-variable\">to_be_bytes</span>();\n\n    <span class=\"cm-comment\">&#47;&#47; Overwrite key rn1 with a subtree</span>\n    <span class=\"cm-comment\">&#47;&#47; Call this SUBTREE3</span>\n    <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>(\n        [<span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">KEY2</span>],\n        &amp;<span class=\"cm-variable\">rn1</span>,\n        <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">empty_tree</span>(),\n        <span class=\"cm-variable\">INSERT_OPTIONS</span>,\n        <span class=\"cm-builtin\">None</span>,\n    )\n    .<span class=\"cm-variable\">unwrap</span>()\n    .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful SUBTREE3 insert\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Populate SUBTREE3 with values 50 through 74 under keys 50 through 74</span>\n    <span class=\"cm-keyword\">for</span> <span class=\"cm-variable\">i</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-number\">50u8</span>..<span class=\"cm-number\">75</span> {\n        <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">i_vec</span> <span class=\"cm-operator\">=</span> (<span class=\"cm-variable\">i</span> <span class=\"cm-keyword\">as</span> <span class=\"cm-atom\">u8</span>).<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>();\n        <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>(\n            [<span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-variable\">rn1</span>],\n            &amp;<span class=\"cm-variable\">i_vec</span>,\n            <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">new_item</span>(<span class=\"cm-variable\">i_vec</span>.<span class=\"cm-variable\">clone</span>()),\n            <span class=\"cm-variable\">INSERT_OPTIONS</span>,\n            <span class=\"cm-builtin\">None</span>,\n        )\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successfully inserted values in SUBTREE3\"</span>);\n    }\n\n    <span class=\"cm-comment\">&#47;&#47; Overwrite key rn2 with a subtree</span>\n    <span class=\"cm-comment\">&#47;&#47; Call this SUBTREE4</span>\n    <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>(\n        [<span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-variable\">rn1</span>],\n        &amp;<span class=\"cm-variable\">rn2</span>,\n        <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">empty_tree</span>(),\n        <span class=\"cm-variable\">INSERT_OPTIONS</span>,\n        <span class=\"cm-builtin\">None</span>,\n    )\n    .<span class=\"cm-variable\">unwrap</span>()\n    .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful SUBTREE4 insert\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Put an empty subtree into SUBTREE4 at KEY3.</span>\n    <span class=\"cm-comment\">&#47;&#47; Call this SUBTREE5.</span>\n    <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>([<span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-variable\">rn1</span>, <span class=\"cm-variable\">rn2</span>], <span class=\"cm-variable\">KEY3</span>, <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">empty_tree</span>(), <span class=\"cm-variable\">INSERT_OPTIONS</span>, <span class=\"cm-builtin\">None</span>)\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successful SUBTREE5 insert\"</span>);\n\n    <span class=\"cm-comment\">&#47;&#47; Populate SUBTREE5 with values 75 through 99 under keys 75 through 99</span>\n    <span class=\"cm-keyword\">for</span> <span class=\"cm-variable\">i</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-number\">75u8</span>..<span class=\"cm-number\">99</span> {\n        <span class=\"cm-keyword\">let</span> <span class=\"cm-def\">i_vec</span> <span class=\"cm-operator\">=</span> (<span class=\"cm-variable\">i</span> <span class=\"cm-keyword\">as</span> <span class=\"cm-atom\">u8</span>).<span class=\"cm-variable\">to_be_bytes</span>().<span class=\"cm-variable\">to_vec</span>();\n        <span class=\"cm-variable\">db</span>.<span class=\"cm-variable\">insert</span>(\n            [<span class=\"cm-variable\">KEY1</span>, <span class=\"cm-variable\">KEY2</span>, <span class=\"cm-variable\">rn1</span>, <span class=\"cm-variable\">rn2</span>, <span class=\"cm-variable\">KEY3</span>],\n            &amp;<span class=\"cm-variable\">i_vec</span>,\n            <span class=\"cm-variable\">Element</span>::<span class=\"cm-variable\">new_item</span>(<span class=\"cm-variable\">i_vec</span>.<span class=\"cm-variable\">clone</span>()),\n            <span class=\"cm-variable\">INSERT_OPTIONS</span>,\n            <span class=\"cm-builtin\">None</span>,\n        )\n        .<span class=\"cm-variable\">unwrap</span>()\n        .<span class=\"cm-variable\">expect</span>(<span class=\"cm-string\">\"successfully inserted values in SUBTREE5\"</span>);\n    }\n}</span>\n</code></pre>\n<p>The terminal output depends on which random numbers were generated. A few of the possibilities are shown below.</p>\n<p>Random number 1 does not fall between 20-25:</p>\n<pre><code>[[22], [23], [24], [25], [26], [27], [28], [29]]\n</code></pre><p>Random number 1 is 23, random number 2 is not 60:</p>\n<pre><code>[[60], [70], [24], [25], [26], [27], [28], [29]]\n</code></pre><p>Random number 1 is 21, random number 2 is 60:</p>\n<pre><code>[[92], [93], [94], [70], [22], [23], [24], [25], [26], [27]]\n</code></pre>\n</div>"
}