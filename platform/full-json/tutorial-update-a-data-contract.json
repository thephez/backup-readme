{
 "metadata": {
  "image": [],
  "title": "",
  "description": "",
  "keywords": "",
  "robots": "index"
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 200
    },
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 400
    }
   ]
  },
  "params": [],
  "examples": {
   "codes": []
  }
 },
 "next": {
  "description": "",
  "pages": []
 },
 "algolia": {
  "recordCount": 4,
  "publishPending": false,
  "translationFailure": false,
  "updatedAt": "2023-09-12T17:05:42.850Z"
 },
 "title": "Update a Data Contract",
 "icon": "",
 "updates": [
  "64381c63a1a36e00117a8450"
 ],
 "type": "basic",
 "slug": "tutorial-update-a-data-contract",
 "excerpt": "Update an existing Dash Platform data contract to add new features",
 "body": "# Overview\n\nSince Dash Platform v0.22, it is possible to update existing data contracts in certain backwards-compatible ways. This includes:\n\n- Adding new documents\n- Adding new optional properties to existing documents\n- Adding _non-unique_ indices for properties added in the update.\n\nIn this tutorial we will update an existing data contract. \n\n## Prerequisites\n\n- [General prerequisites](tutorials-introduction#prerequisites) (Node.js / Dash SDK installed)\n- A wallet mnemonic with some funds in it: [Tutorial: Create and Fund a Wallet](tutorial-create-and-fund-a-wallet)\n- A Dash Platform Identity: [Tutorial: Register an Identity](tutorial-register-an-identity)\n- A Dash Platform Contract ID: [Tutorial: Register a Data Contract](tutorial-register-a-data-contract) \n\n# Code\n\nThe following example demonstrates updating an existing contract to add a new property to an existing document:\n\n```javascript\nconst Dash = require('dash');\n\nconst clientOpts = {\n  network: 'testnet',\n  wallet: {\n    mnemonic: 'a Dash wallet mnemonic with funds goes here',\n    unsafeOptions: {\n      skipSynchronizationBeforeHeight: 650000, // only sync from early-2022\n    },    \n  },\n};\nconst client = new Dash.Client(clientOpts);\n\nconst updateContract = async () => {\n  const { platform } = client;\n  const identity = await platform.identities.get('an identity ID goes here');\n\n  const existingDataContract = await platform.contracts.get('a contract ID goes here');\n    const documentSchema = existingDataContract.getDocumentSchema('note');\n\n  documentSchema.properties.author = {\n    type: 'string',\n  };\n\n  existingDataContract.setDocumentSchema('note', documentSchema);\n\n  // Sign and submit the data contract\n  await platform.contracts.update(existingDataContract, identity);\n  return existingDataContract;\n};\n\nupdateContract()\n  .then((d) => console.log('Contract updated:\\n', d.toJSON()))\n  .catch((e) => console.error('Something went wrong:\\n', e))\n  .finally(() => client.disconnect());\n```\n\n> \ud83d\udcd8 \n> \n> Please refer to the [data contract reference page](reference-data-contracts) for more comprehensive details related to contracts and documents.\n\n# What's Happening\n\nAfter we initialize the Client, we retrieve an existing contract owned by our identity. We then get the contract's document schema and modify a document (adding an `author` property to the `note` document in the example). The `setDocumentSchema` method takes two arguments: the name of the document schema to be updated and the object containing the updated document types.\n\nOnce the data contract has been updated, we still need to submit it to DAPI. The `platform.contracts.update` method takes a data contract and an identity parameter. Internally, it creates a State Transition containing the updated contract, signs the state transition, and submits the signed state transition to DAPI. A response will only be returned if an error is encountered.\n\n> \ud83d\udcd8 Wallet Operations\n> \n> The JavaScript SDK does not cache wallet information. It re-syncs the entire Core chain for some wallet operations (e.g. `client.getWalletAccount()`) which can result in wait times of  5+ minutes. \n> \n> A future release will add caching so that access is much faster after the initial sync. For now, the `skipSynchronizationBeforeHeight` option can be used to sync the wallet starting at a certain block height.",
 "order": 2,
 "isReference": false,
 "deprecated": false,
 "hidden": false,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "reusableContent": [],
 "previousSlug": "",
 "slugUpdatedAt": "2022-01-26T20:20:02.779Z",
 "revision": 7,
 "_id": "64f8a9df750465004742add6",
 "pendingAlgoliaPublish": false,
 "createdAt": "2022-01-27T17:12:04.140Z",
 "updatedAt": "2023-09-12T17:05:42.670Z",
 "user": "5b8400d7185d5e00036dcc3b",
 "parentDoc": "64f8a9df750465004742adc8",
 "category": "64f8a9df750465004742ad6e",
 "project": "5bda01cad172e200499a20a9",
 "version": "64f8a9df750465004742ae1d",
 "__v": 1,
 "isApi": false,
 "id": "64f8a9df750465004742add6",
 "body_html": "# Overview\n\nSince Dash Platform v0.22, it is possible to update existing data contracts in certain backwards-compatible ways. This includes:\n\n- Adding new documents\n- Adding new optional properties to existing documents\n- Adding _non-unique_ indices for properties added in the update.\n\nIn this tutorial we will update an existing data contract. \n\n## Prerequisites\n\n- [General prerequisites](tutorials-introduction#prerequisites) (Node.js / Dash SDK installed)\n- A wallet mnemonic with some funds in it: [Tutorial: Create and Fund a Wallet](tutorial-create-and-fund-a-wallet)\n- A Dash Platform Identity: [Tutorial: Register an Identity](tutorial-register-an-identity)\n- A Dash Platform Contract ID: [Tutorial: Register a Data Contract](tutorial-register-a-data-contract) \n\n# Code\n\nThe following example demonstrates updating an existing contract to add a new property to an existing document:\n\n```javascript\nconst Dash = require('dash');\n\nconst clientOpts = {\n  network: 'testnet',\n  wallet: {\n    mnemonic: 'a Dash wallet mnemonic with funds goes here',\n    unsafeOptions: {\n      skipSynchronizationBeforeHeight: 650000, // only sync from early-2022\n    },    \n  },\n};\nconst client = new Dash.Client(clientOpts);\n\nconst updateContract = async () => {\n  const { platform } = client;\n  const identity = await platform.identities.get('an identity ID goes here');\n\n  const existingDataContract = await platform.contracts.get('a contract ID goes here');\n    const documentSchema = existingDataContract.getDocumentSchema('note');\n\n  documentSchema.properties.author = {\n    type: 'string',\n  };\n\n  existingDataContract.setDocumentSchema('note', documentSchema);\n\n  // Sign and submit the data contract\n  await platform.contracts.update(existingDataContract, identity);\n  return existingDataContract;\n};\n\nupdateContract()\n  .then((d) => console.log('Contract updated:\\n', d.toJSON()))\n  .catch((e) => console.error('Something went wrong:\\n', e))\n  .finally(() => client.disconnect());\n```\n\n> \ud83d\udcd8 \n> \n> Please refer to the [data contract reference page](reference-data-contracts) for more comprehensive details related to contracts and documents.\n\n# What's Happening\n\nAfter we initialize the Client, we retrieve an existing contract owned by our identity. We then get the contract's document schema and modify a document (adding an `author` property to the `note` document in the example). The `setDocumentSchema` method takes two arguments: the name of the document schema to be updated and the object containing the updated document types.\n\nOnce the data contract has been updated, we still need to submit it to DAPI. The `platform.contracts.update` method takes a data contract and an identity parameter. Internally, it creates a State Transition containing the updated contract, signs the state transition, and submits the signed state transition to DAPI. A response will only be returned if an error is encountered.\n\n> \ud83d\udcd8 Wallet Operations\n> \n> The JavaScript SDK does not cache wallet information. It re-syncs the entire Core chain for some wallet operations (e.g. `client.getWalletAccount()`) which can result in wait times of  5+ minutes. \n> \n> A future release will add caching so that access is much faster after the initial sync. For now, the `skipSynchronizationBeforeHeight` option can be used to sync the wallet starting at a certain block height."
}