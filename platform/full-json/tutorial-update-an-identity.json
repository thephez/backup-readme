{
 "metadata": {
  "image": [],
  "title": "",
  "description": "",
  "keywords": "",
  "robots": "index"
 },
 "api": {
  "method": "get",
  "url": "",
  "auth": "required",
  "results": {
   "codes": [
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 200
    },
    {
     "name": "",
     "code": "{}",
     "language": "json",
     "status": 400
    }
   ]
  },
  "params": [],
  "examples": {
   "codes": []
  }
 },
 "next": {
  "description": "",
  "pages": []
 },
 "algolia": {
  "recordCount": 6,
  "publishPending": false,
  "translationFailure": false,
  "updatedAt": "2023-09-12T19:22:31.756Z"
 },
 "title": "Update an Identity",
 "icon": "",
 "updates": [],
 "type": "basic",
 "slug": "tutorial-update-an-identity",
 "excerpt": "Update the keys of an existing Identity",
 "body": "# Overview\n\nSince Dash Platform v0.23, it is possible to update identities to add new keys or disable existing ones. Platform retains disabled keys so that any existing data they signed can still be verified while preventing them from signing new data. \n\n# Prerequisites\n\n- [General prerequisites](tutorials-introduction#prerequisites) (Node.js / Dash SDK installed)\n- A wallet mnemonic with some funds in it: [Tutorial: Create and Fund a Wallet](tutorial-create-and-fund-a-wallet)\n- A Dash Platform Identity: [Tutorial: Register an Identity](tutorial-register-an-identity)\n\n# Code\n\nThe two examples below demonstrate updating an existing identity to add a new key and disabling an existing key:\n\n> \ud83d\udea7 \n> \n> The current SDK version signs all state transitions with public key id `1`. If it is disabled, the SDK will be unable to use the identity. Future SDK versions will provide a way to also sign using keys added in an identity update.\n\n```javascript Disable identity key\nconst Dash = require('dash');\n\nconst clientOpts = {\n  network: 'testnet',\n  wallet: {\n    mnemonic: 'a Dash wallet mnemonic with funds goes here',\n    unsafeOptions: {\n      skipSynchronizationBeforeHeight: 650000, // only sync from early-2022\n    },    \n  },\n};\nconst client = new Dash.Client(clientOpts);\n\nconst updateIdentityDisableKey = async () => {\n  const identityId = 'an identity ID goes here';\n  const keyId = 'a public key ID goes here'; // One of the identity's public key IDs\n\n  // Retrieve the identity to be updated and the public key to disable\n  const existingIdentity = await client.platform.identities.get(identityId);\n  const publicKeyToDisable = existingIdentity.getPublicKeyById(keyId);\n\n  const updateDisable = {\n    disable: [publicKeyToDisable],\n  };\n\n  await client.platform.identities.update(existingIdentity, updateDisable);\n  return client.platform.identities.get(identityId);\n}\n\nupdateIdentityDisableKey()\n  .then((d) => console.log('Identity updated:\\n', d.toJSON()))\n  .catch((e) => console.error('Something went wrong:\\n', e))\n  .finally(() => client.disconnect());\n```\n```javascript Add identity key\nconst Dash = require('dash');\nconst { IdentityPublicKey, IdentityPublicKeyWithWitness } = require('@dashevo/wasm-dpp');\n\nconst clientOpts = {\n  network: 'testnet',\n  wallet: {\n    mnemonic: 'a Dash wallet mnemonic with funds goes here',\n    unsafeOptions: {\n      skipSynchronizationBeforeHeight: 650000, // only sync from early-2022\n    },    \n  },\n};\nconst client = new Dash.Client(clientOpts);\n\nconst updateIdentityAddKey = async () => {\n  const identityId = 'an identity ID goes here';\n  const existingIdentity = await client.platform.identities.get(identityId);\n  const newKeyId = existingIdentity.toJSON().publicKeys.length;\n\n  // Get an unused identity index\n  const account = await client.platform.client.getWalletAccount();\n  const identityIndex = await account.getUnusedIdentityIndex();\n\n  // Get unused private key and construct new identity public key\n  const { privateKey: identityPrivateKey } =\n    account.identities.getIdentityHDKeyByIndex(identityIndex, 0);\n\n  const identityPublicKey = identityPrivateKey.toPublicKey().toBuffer();\n\n  const newPublicKey = new IdentityPublicKeyWithWitness(1);\n  newPublicKey.setId(newKeyId);\n  newPublicKey.setSecurityLevel(IdentityPublicKey.SECURITY_LEVELS.HIGH);\n  newPublicKey.setData(identityPublicKey);  \n\n  const updateAdd = {\n    add: [newPublicKey],\n  };\n\n  // Submit the update signed with the new key\n  await client.platform.identities.update(existingIdentity, updateAdd, {\n    [newPublicKey.getId()]: identityPrivateKey,\n  });\n\n  return client.platform.identities.get(identityId);};\n};\n\nupdateIdentityAddKey()\n  .then((d) => console.log('Identity updated:\\n', d.toJSON()))\n  .catch((e) => console.error('Something went wrong:\\n', e))\n  .finally(() => client.disconnect());\n```\n\n# What's Happening\n\n## Disabling keys\n\nAfter we initialize the Client, we retrieve our existing identity and provide the `id` of one (or more) of the identity keys to disable. The update is submitted to DAPI using the `platform.identities.update` method with two arguments:\n\n1. An identity\n2. An object containing the key(s) to be disabled\n\nInternally, the method creates a State Transition containing the updated identity, signs the state transition, and submits the signed state transition to DAPI. After the identity is updated, we output it to the console.\n\n## Adding keys\n\nAfter we initialize the Client, we retrieve our existing identity and set an `id` for the key to be added. Next, we get an unused private key from our wallet and use it to derive a public key to add to our identity. The update is submitted to DAPI using the `platform.identities.update` method with three arguments:\n\n1. An identity\n2. An object containing the key(s) to be added\n3. An object containing the id and private key for each public key being added\n\n> \ud83d\udcd8 \n> \n> When adding new public keys, they must be signed using the associated private key to prove ownership of the keys.\n\nInternally, the method creates a State Transition containing the updated identity, signs the state transition, and submits the signed state transition to DAPI. After the identity is updated, we output it to the console.",
 "order": 3,
 "isReference": false,
 "deprecated": false,
 "hidden": false,
 "sync_unique": "",
 "link_url": "",
 "link_external": false,
 "reusableContent": [],
 "previousSlug": "",
 "slugUpdatedAt": "2022-08-10T19:44:06.646Z",
 "revision": 8,
 "_id": "64f8a9df750465004742adda",
 "pendingAlgoliaPublish": false,
 "createdAt": "2022-08-11T13:31:41.348Z",
 "updatedAt": "2023-09-12T19:22:31.562Z",
 "user": "5b8400d7185d5e00036dcc3b",
 "parentDoc": "64f8a9df750465004742adc9",
 "category": "64f8a9df750465004742ad6e",
 "project": "5bda01cad172e200499a20a9",
 "version": "64f8a9df750465004742ae1d",
 "__v": 0,
 "isApi": false,
 "id": "64f8a9df750465004742adda",
 "body_html": "# Overview\n\nSince Dash Platform v0.23, it is possible to update identities to add new keys or disable existing ones. Platform retains disabled keys so that any existing data they signed can still be verified while preventing them from signing new data. \n\n# Prerequisites\n\n- [General prerequisites](tutorials-introduction#prerequisites) (Node.js / Dash SDK installed)\n- A wallet mnemonic with some funds in it: [Tutorial: Create and Fund a Wallet](tutorial-create-and-fund-a-wallet)\n- A Dash Platform Identity: [Tutorial: Register an Identity](tutorial-register-an-identity)\n\n# Code\n\nThe two examples below demonstrate updating an existing identity to add a new key and disabling an existing key:\n\n> \ud83d\udea7 \n> \n> The current SDK version signs all state transitions with public key id `1`. If it is disabled, the SDK will be unable to use the identity. Future SDK versions will provide a way to also sign using keys added in an identity update.\n\n```javascript Disable identity key\nconst Dash = require('dash');\n\nconst clientOpts = {\n  network: 'testnet',\n  wallet: {\n    mnemonic: 'a Dash wallet mnemonic with funds goes here',\n    unsafeOptions: {\n      skipSynchronizationBeforeHeight: 650000, // only sync from early-2022\n    },    \n  },\n};\nconst client = new Dash.Client(clientOpts);\n\nconst updateIdentityDisableKey = async () => {\n  const identityId = 'an identity ID goes here';\n  const keyId = 'a public key ID goes here'; // One of the identity's public key IDs\n\n  // Retrieve the identity to be updated and the public key to disable\n  const existingIdentity = await client.platform.identities.get(identityId);\n  const publicKeyToDisable = existingIdentity.getPublicKeyById(keyId);\n\n  const updateDisable = {\n    disable: [publicKeyToDisable],\n  };\n\n  await client.platform.identities.update(existingIdentity, updateDisable);\n  return client.platform.identities.get(identityId);\n}\n\nupdateIdentityDisableKey()\n  .then((d) => console.log('Identity updated:\\n', d.toJSON()))\n  .catch((e) => console.error('Something went wrong:\\n', e))\n  .finally(() => client.disconnect());\n```\n```javascript Add identity key\nconst Dash = require('dash');\nconst { IdentityPublicKey, IdentityPublicKeyWithWitness } = require('@dashevo/wasm-dpp');\n\nconst clientOpts = {\n  network: 'testnet',\n  wallet: {\n    mnemonic: 'a Dash wallet mnemonic with funds goes here',\n    unsafeOptions: {\n      skipSynchronizationBeforeHeight: 650000, // only sync from early-2022\n    },    \n  },\n};\nconst client = new Dash.Client(clientOpts);\n\nconst updateIdentityAddKey = async () => {\n  const identityId = 'an identity ID goes here';\n  const existingIdentity = await client.platform.identities.get(identityId);\n  const newKeyId = existingIdentity.toJSON().publicKeys.length;\n\n  // Get an unused identity index\n  const account = await client.platform.client.getWalletAccount();\n  const identityIndex = await account.getUnusedIdentityIndex();\n\n  // Get unused private key and construct new identity public key\n  const { privateKey: identityPrivateKey } =\n    account.identities.getIdentityHDKeyByIndex(identityIndex, 0);\n\n  const identityPublicKey = identityPrivateKey.toPublicKey().toBuffer();\n\n  const newPublicKey = new IdentityPublicKeyWithWitness(1);\n  newPublicKey.setId(newKeyId);\n  newPublicKey.setSecurityLevel(IdentityPublicKey.SECURITY_LEVELS.HIGH);\n  newPublicKey.setData(identityPublicKey);  \n\n  const updateAdd = {\n    add: [newPublicKey],\n  };\n\n  // Submit the update signed with the new key\n  await client.platform.identities.update(existingIdentity, updateAdd, {\n    [newPublicKey.getId()]: identityPrivateKey,\n  });\n\n  return client.platform.identities.get(identityId);};\n};\n\nupdateIdentityAddKey()\n  .then((d) => console.log('Identity updated:\\n', d.toJSON()))\n  .catch((e) => console.error('Something went wrong:\\n', e))\n  .finally(() => client.disconnect());\n```\n\n# What's Happening\n\n## Disabling keys\n\nAfter we initialize the Client, we retrieve our existing identity and provide the `id` of one (or more) of the identity keys to disable. The update is submitted to DAPI using the `platform.identities.update` method with two arguments:\n\n1. An identity\n2. An object containing the key(s) to be disabled\n\nInternally, the method creates a State Transition containing the updated identity, signs the state transition, and submits the signed state transition to DAPI. After the identity is updated, we output it to the console.\n\n## Adding keys\n\nAfter we initialize the Client, we retrieve our existing identity and set an `id` for the key to be added. Next, we get an unused private key from our wallet and use it to derive a public key to add to our identity. The update is submitted to DAPI using the `platform.identities.update` method with three arguments:\n\n1. An identity\n2. An object containing the key(s) to be added\n3. An object containing the id and private key for each public key being added\n\n> \ud83d\udcd8 \n> \n> When adding new public keys, they must be signed using the associated private key to prove ownership of the keys.\n\nInternally, the method creates a State Transition containing the updated identity, signs the state transition, and submits the signed state transition to DAPI. After the identity is updated, we output it to the console."
}